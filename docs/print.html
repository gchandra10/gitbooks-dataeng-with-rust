<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Engineering with Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="frontpage.html">Front Page</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter1/index.html"><strong aria-hidden="true">1.</strong> Chapter 1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter1/programming/index.html"><strong aria-hidden="true">1.1.</strong> Programming Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter1/programming/overview.html"><strong aria-hidden="true">1.1.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="chapter1/programming/dsl.html"><strong aria-hidden="true">1.1.2.</strong> DSL</a></li><li class="chapter-item expanded "><a href="chapter1/programming/gpl.html"><strong aria-hidden="true">1.1.3.</strong> GPL</a></li><li class="chapter-item expanded "><a href="chapter1/programming/compiler-vs-interpreter.html"><strong aria-hidden="true">1.1.4.</strong> Compiler vs Interpreter</a></li><li class="chapter-item expanded "><a href="chapter1/programming/static-vs-dynamic.html"><strong aria-hidden="true">1.1.5.</strong> Static vs Dynamic</a></li><li class="chapter-item expanded "><a href="chapter1/programming/strongly-typed-vs-weakly-typed.html"><strong aria-hidden="true">1.1.6.</strong> Strongly vs Weakly Typed</a></li><li class="chapter-item expanded "><a href="chapter1/programming/programming-matrix.html"><strong aria-hidden="true">1.1.7.</strong> Programming Matrix</a></li></ol></li><li class="chapter-item expanded "><a href="chapter1/rust-overview/index.html"><strong aria-hidden="true">1.2.</strong> Rust Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter1/rust-overview/rust-overview.html"><strong aria-hidden="true">1.2.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="chapter1/rust-overview/rust-is-used-for.html"><strong aria-hidden="true">1.2.2.</strong> Rust Used For</a></li><li class="chapter-item expanded "><a href="chapter1/rust-overview/commonly-used-attributes.html"><strong aria-hidden="true">1.2.3.</strong> Commonly used Attributes</a></li><li class="chapter-item expanded "><a href="chapter1/rust-overview/playground-demo.html"><strong aria-hidden="true">1.2.4.</strong> Rust Playground</a></li><li class="chapter-item expanded "><a href="chapter1/rust-overview/rust-installation.html"><strong aria-hidden="true">1.2.5.</strong> Rust Installation</a></li><li class="chapter-item expanded "><a href="chapter1/rust-overview/vs-code.html"><strong aria-hidden="true">1.2.6.</strong> VS Code</a></li><li class="chapter-item expanded "><a href="chapter1/rust-overview/cargo.html"><strong aria-hidden="true">1.2.7.</strong> Cargo</a></li><li class="chapter-item expanded "><a href="chapter1/rust-overview/cargo-example.html"><strong aria-hidden="true">1.2.8.</strong> Cargo Example</a></li><li class="chapter-item expanded "><a href="chapter1/rust-overview/cargo-dependency-versions.html"><strong aria-hidden="true">1.2.9.</strong> Cargo Dependency Versions</a></li></ol></li><li class="chapter-item expanded "><a href="chapter1/starter-crates/index.html"><strong aria-hidden="true">1.3.</strong> Starter Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter1/starter-crates/basic-program.html"><strong aria-hidden="true">1.3.1.</strong> Basic Programs</a></li><li class="chapter-item expanded "><a href="chapter1/starter-crates/comments.html"><strong aria-hidden="true">1.3.2.</strong> Comments</a></li><li class="chapter-item expanded "><a href="chapter1/starter-crates/variables.html"><strong aria-hidden="true">1.3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="chapter1/starter-crates/simple-rust-programs.html"><strong aria-hidden="true">1.3.4.</strong> Simple Rust Programs</a></li><li class="chapter-item expanded "><a href="chapter1/starter-crates/pretty-please-print.html"><strong aria-hidden="true">1.3.5.</strong> Pretty Print</a></li><li class="chapter-item expanded "><a href="chapter1/starter-crates/escape-printing.html"><strong aria-hidden="true">1.3.6.</strong> Escape Printing</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="chapter2/index.html"><strong aria-hidden="true">2.</strong> Chapter 2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter2/data-types/index.html"><strong aria-hidden="true">2.1.</strong> Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter2/data-types/overview.html"><strong aria-hidden="true">2.1.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="chapter2/data-types/integer.html"><strong aria-hidden="true">2.1.2.</strong> Integer</a></li><li class="chapter-item expanded "><a href="chapter2/data-types/floating-point.html"><strong aria-hidden="true">2.1.3.</strong> Floating-point</a></li><li class="chapter-item expanded "><a href="chapter2/data-types/boolean.html"><strong aria-hidden="true">2.1.4.</strong> Boolean</a></li><li class="chapter-item expanded "><a href="chapter2/data-types/char-and-strings.html"><strong aria-hidden="true">2.1.5.</strong> Char & Strings</a></li><li class="chapter-item expanded "><a href="chapter2/data-types/string-based-programs.html"><strong aria-hidden="true">2.1.6.</strong> String based crates</a></li><li class="chapter-item expanded "><a href="chapter2/data-types/arrays.html"><strong aria-hidden="true">2.1.7.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="chapter2/data-types/tuples.html"><strong aria-hidden="true">2.1.8.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="chapter2/data-types/constants.html"><strong aria-hidden="true">2.1.9.</strong> Constants</a></li><li class="chapter-item expanded "><a href="chapter2/data-types/unit-type.html"><strong aria-hidden="true">2.1.10.</strong> Unit-type</a></li></ol></li><li class="chapter-item expanded "><a href="chapter2/and-and.html"><strong aria-hidden="true">2.2.</strong> Reference - Dereference</a></li><li class="chapter-item expanded "><a href="chapter2/expression.html"><strong aria-hidden="true">2.3.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="chapter2/operators/index.html"><strong aria-hidden="true">2.4.</strong> Operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter2/operators/binary-operators.html"><strong aria-hidden="true">2.4.1.</strong> Binary Operators</a></li></ol></li><li class="chapter-item expanded "><a href="chapter2/flow-of-control/index.html"><strong aria-hidden="true">2.5.</strong> Flow of control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter2/flow-of-control/match.html"><strong aria-hidden="true">2.5.1.</strong> Match</a></li></ol></li><li class="chapter-item expanded "><a href="chapter2/functions.html"><strong aria-hidden="true">2.6.</strong> Functions</a></li><li class="chapter-item expanded "><a href="chapter2/unit-tests/index.html"><strong aria-hidden="true">2.7.</strong> Unit Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter2/unit-tests/calculator.html"><strong aria-hidden="true">2.7.1.</strong> Calculator</a></li><li class="chapter-item expanded "><a href="chapter2/unit-tests/assert-macros.html"><strong aria-hidden="true">2.7.2.</strong> Assert Macros</a></li><li class="chapter-item expanded "><a href="chapter2/unit-tests/control-cargo-tests.html"><strong aria-hidden="true">2.7.3.</strong> Cargo Test examples</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="chapter3/index.html"><strong aria-hidden="true">3.</strong> chapter3</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter3/enumerator.html"><strong aria-hidden="true">3.1.</strong> enumerator</a></li><li class="chapter-item expanded "><a href="chapter3/iterator.html"><strong aria-hidden="true">3.2.</strong> iterator</a></li><li class="chapter-item expanded "><a href="chapter3/slices.html"><strong aria-hidden="true">3.3.</strong> slices</a></li><li class="chapter-item expanded "><a href="chapter3/memory-management/index.html"><strong aria-hidden="true">3.4.</strong> memory-management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter3/memory-management/stack-heap.html"><strong aria-hidden="true">3.4.1.</strong> stack-heap</a></li><li class="chapter-item expanded "><a href="chapter3/memory-management/borrowing-references.html"><strong aria-hidden="true">3.4.2.</strong> borrowing-references</a></li><li class="chapter-item expanded "><a href="chapter3/memory-management/ownership.html"><strong aria-hidden="true">3.4.3.</strong> ownership</a></li><li class="chapter-item expanded "><a href="chapter3/memory-management/borrowers.html"><strong aria-hidden="true">3.4.4.</strong> borrowers</a></li><li class="chapter-item expanded "><a href="chapter3/memory-management/owner-borrower-stack-heap.html"><strong aria-hidden="true">3.4.5.</strong> owner-borrower-stack-heap</a></li><li class="chapter-item expanded "><a href="chapter3/memory-management/dangling-references.html"><strong aria-hidden="true">3.4.6.</strong> dangling-references</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="chapter4/index.html"><strong aria-hidden="true">4.</strong> chapter4</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter4/command-line-args.html"><strong aria-hidden="true">4.1.</strong> command-line-args</a></li><li class="chapter-item expanded "><a href="chapter4/input-from-user.html"><strong aria-hidden="true">4.2.</strong> input-from-user</a></li><li class="chapter-item expanded "><a href="chapter4/vector-struct-input.html"><strong aria-hidden="true">4.3.</strong> vector-struct-input</a></li><li class="chapter-item expanded "><a href="chapter4/complex-datatypes/index.html"><strong aria-hidden="true">4.4.</strong> complex-datatypes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter4/complex-datatypes/vector-datatype.html"><strong aria-hidden="true">4.4.1.</strong> vector-datatype</a></li><li class="chapter-item expanded "><a href="chapter4/complex-datatypes/structs.html"><strong aria-hidden="true">4.4.2.</strong> structs</a></li><li class="chapter-item expanded "><a href="chapter4/complex-datatypes/enums.html"><strong aria-hidden="true">4.4.3.</strong> enums</a></li><li class="chapter-item expanded "><a href="chapter4/complex-datatypes/hash-map.html"><strong aria-hidden="true">4.4.4.</strong> hash-map</a></li><li class="chapter-item expanded "><a href="chapter4/complex-datatypes/type-alias.html"><strong aria-hidden="true">4.4.5.</strong> type-alias</a></li></ol></li><li class="chapter-item expanded "><a href="chapter4/modules/index.html"><strong aria-hidden="true">4.5.</strong> modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter4/modules/module-sub-folders.html"><strong aria-hidden="true">4.5.1.</strong> module-sub-folders</a></li><li class="chapter-item expanded "><a href="chapter4/modules/module-multiple-files.html"><strong aria-hidden="true">4.5.2.</strong> module-multiple-files</a></li><li class="chapter-item expanded "><a href="chapter4/modules/user-defined-module.html"><strong aria-hidden="true">4.5.3.</strong> user-defined-module</a></li><li class="chapter-item expanded "><a href="chapter4/modules/creating-a-library.html"><strong aria-hidden="true">4.5.4.</strong> creating-a-library</a></li><li class="chapter-item expanded "><a href="chapter4/modules/standard-modules.html"><strong aria-hidden="true">4.5.5.</strong> standard-modules</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="chapter5/index.html"><strong aria-hidden="true">5.</strong> chapter5</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter5/macros.html"><strong aria-hidden="true">5.1.</strong> macros</a></li><li class="chapter-item expanded "><a href="chapter5/traits.html"><strong aria-hidden="true">5.2.</strong> traits</a></li><li class="chapter-item expanded "><a href="chapter5/generics.html"><strong aria-hidden="true">5.3.</strong> generics</a></li><li class="chapter-item expanded "><a href="chapter5/json.html"><strong aria-hidden="true">5.4.</strong> json</a></li><li class="chapter-item expanded "><a href="chapter5/file-handling.html"><strong aria-hidden="true">5.5.</strong> file-handling</a></li><li class="chapter-item expanded "><a href="chapter5/log4j.html"><strong aria-hidden="true">5.6.</strong> log4j</a></li><li class="chapter-item expanded "><a href="chapter5/smart-pointers.html"><strong aria-hidden="true">5.7.</strong> smart-pointers</a></li><li class="chapter-item expanded "><a href="chapter5/closures.html"><strong aria-hidden="true">5.8.</strong> closures</a></li><li class="chapter-item expanded "><a href="chapter5/database.html"><strong aria-hidden="true">5.9.</strong> database</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="nice-to-know/index.html"><strong aria-hidden="true">6.</strong> nice-to-know</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="nice-to-know/cargo-publish.html"><strong aria-hidden="true">6.1.</strong> cargo-publish</a></li><li class="chapter-item expanded "><a href="nice-to-know/cargo-watch.html"><strong aria-hidden="true">6.2.</strong> cargo-watch</a></li><li class="chapter-item expanded "><a href="nice-to-know/big-o-notation.html"><strong aria-hidden="true">6.3.</strong> big-o-notation</a></li><li class="chapter-item expanded "><a href="nice-to-know/important-concepts.html"><strong aria-hidden="true">6.4.</strong> important-concepts</a></li><li class="chapter-item expanded "><a href="nice-to-know/cargo-audit.html"><strong aria-hidden="true">6.5.</strong> cargo-audit</a></li><li class="chapter-item expanded "><a href="nice-to-know/cargo-profiles.html"><strong aria-hidden="true">6.6.</strong> cargo-profiles</a></li></ol></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">7.</strong> references</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Data Engineering with Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="front-page"><a class="header" href="#front-page">Front Page</a></h1>
<h2 id="class-notes"><a class="header" href="#class-notes">Class Notes</a></h2>
<p>This is not an official Textbook for Rust Programming. (Still, lot more to come)</p>
<p>The official documentation is mentioned in the Appendix section.</p>
<p>This is the only reference material with the lecture presented in the class. </p>
<p>If you find any errors, please do email me at chandr34 @ rowan.edu</p>
<figure><img src="assets/00_information_overloaded.png" alt=""><figcaption></figcaption></figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1"><a class="header" href="#chapter-1">Chapter 1</a></h1>
<ul>
<li>
<p><a href="chapter1/programming/README.html">Programming</a></p>
<ul>
<li><a href="chapter1/programming/overview.html">Overview</a></li>
<li><a href="chapter1/programming/dsl.html">DSL</a></li>
<li><a href="chapter1/programming/gpl.html">GPL</a></li>
<li><a href="chapter1/programming/compiler-vs-interpreter.html">Compiler vs Interpreter</a></li>
<li><a href="chapter1/programming/static-vs-dynamic.html">Static vs Dynamic</a></li>
<li><a href="chapter1/programming/strongly-typed-vs-weakly-typed.html">Strongly Typed vs Weakly Typed</a></li>
<li><a href="chapter1/programming/programming-matrix.html">Programming Matrix</a></li>
</ul>
</li>
<li>
<p><a href="chapter1/rust-overview/README.html">Rust Overview</a></p>
<ul>
<li><a href="chapter1/rust-overview/rust-overview.html">Overview</a></li>
<li><a href="chapter1/rust-overview/rust-is-used-for.html">Uses Cases</a></li>
<li><a href="chapter1/rust-overview/commonly-used-attributes.html">Commonly Used Attributes</a></li>
<li><a href="chapter1/rust-overview/playground-demo.html">Playground - Demo</a></li>
<li><a href="chapter1/rust-overview/rust-installation.html">Rust Installation</a></li>
<li><a href="chapter1/rust-overview/vs-code.html">VS Code</a></li>
<li><a href="chapter1/rust-overview/cargo.html">Cargo</a></li>
<li><a href="chapter1/rust-overview/cargo.toml.html">Cargo.toml</a></li>
<li><a href="chapter1/rust-overview/cargo.lock.html">Cargo.lock</a></li>
<li><a href="chapter1/rust-overview/cargo-example.html">Cargo Example</a></li>
<li><a href="chapter1/rust-overview/cargo-dependency-versions.html">Cargo Dependency Versions</a></li>
</ul>
</li>
<li>
<p><a href="chapter1/starter-crates/README.html">Starter Crates</a></p>
<ul>
<li><a href="chapter1/starter-crates/basic-program.html">Basic Programs</a></li>
<li><a href="chapter1/starter-crates/comments.html">Comments</a></li>
<li><a href="chapter1/starter-crates/variables.html">Variables</a></li>
<li><a href="chapter1/starter-crates/simple-rust-programs.html">Simple Rust Programs</a></li>
<li><a href="chapter1/starter-crates/pretty-please-print.html">Pretty Print</a></li>
<li><a href="chapter1/starter-crates/escape-printing.html">Escape Printing</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming"><a class="header" href="#programming">Programming</a></h1>
<ul>
<li><a href="chapter1/programming/overview.html">Overview</a></li>
<li><a href="chapter1/programming/dsl.html">DSL</a></li>
<li><a href="chapter1/programming/gpl.html">GPL</a></li>
<li><a href="chapter1/programming/compiler-vs-interpreter.html">Compiler vs Interpreter</a></li>
<li><a href="chapter1/programming/static-vs-dynamic.html">Static vs Dynamic</a></li>
<li><a href="chapter1/programming/strongly-typed-vs-weakly-typed.html">Strongly Typed vs Weakly Typed</a></li>
<li><a href="chapter1/programming/programming-matrix.html">Programming Matrix</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<h3 id="why-learn-programming"><a class="header" href="#why-learn-programming">Why Learn Programming?</a></h3>
<blockquote>
<p>“Everybody in this country should learn how to program a computer… because it teaches you how to think” <br />
–<strong>Steve Jobs</strong></p>
</blockquote>
<p>Problem Solving</p>
<p>Automation</p>
<h3 id="how-does-coding-help-you-personally"><a class="header" href="#how-does-coding-help-you-personally">How does coding help you personally?</a></h3>
<p>Develop Interpersonal Skills</p>
<p>Coding is Creativity</p>
<p>Feeling empowered.</p>
<h3 id="why-learn-more-than-one-language"><a class="header" href="#why-learn-more-than-one-language">Why learn more than one Language?</a></h3>
<blockquote>
<p><strong>Mastering more than one language is often a watershed in the career of a professional programmer.</strong> Once a programmer realizes that programming principles transcend the syntax of any specific language, the doors swing open to knowledge that truly makes a difference in quality and productivity. — <em>Steve McConnell</em></p>
</blockquote>
<figure><img src="chapter1/programming/../.gitbook/assets/swiss_army_programming_knife.png" alt=""><figcaption><p><em>Img Src: Brian Johnson (Quora.com)</em></p></figcaption></figure>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="description-domain-specific-language"><a class="header" href="#description-domain-specific-language">description: Domain Specific Language</a></h2>
<h1 id="dsl"><a class="header" href="#dsl">DSL</a></h1>
<p>Domain-specific languages (DSLs) are super interesting because they're tailor-made for specific tasks or industries, like SQL for databases or HTML for web pages.</p>
<p>DSLs can reduce code complexity and increase productivity for specific tasks.</p>
<p>A Domain Specific Language is a programming language with a higher level of abstraction optimized for a specific class of problems. (a.k.a) Specialized to a particular application domain.</p>
<p><strong>15+ DSL available</strong> </p>
<p>Some popular ones are</p>
<p>HTML - HyperText Markup Language</p>
<p>SQL - Structured Query Language</p>
<p>CSS - Cascading Style Sheets</p>
<p>MD - Markdown (github readme.md or <a href="https://stackedit.io/app">https://stackedit.io/app#</a>)</p>
<p>Mermaid - Mermaid  (<a href="https://mermaid.live/">https://mermaid.live/</a>)</p>
<p>Sed - Text Transformation</p>
<p>XML - eXtended Markup Language</p>
<p>UML - Unified Data Modeling</p>
<p>Terraform - Manage Cloud Resources</p>
<img src="chapter1/programming/../.gitbook/assets/image (1).png" alt="" data-size="original">
<p>image src: <a href="https://tomassetti.me/domain-specific-languages/">https://tomassetti.me/domain-specific-languages/</a></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="description-general-programming-language"><a class="header" href="#description-general-programming-language">description: General Programming Language</a></h2>
<h1 id="gpl"><a class="header" href="#gpl">GPL</a></h1>
<p>As the name suggests, Programming languages that are commonly used today</p>
<p>Python</p>
<p>JAVA</p>
<p>C++</p>
<p>RUST</p>
<p>and so on.</p>
<p>Learn and use it for developing a variety of applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-vs-interpreter"><a class="header" href="#compiler-vs-interpreter">Compiler vs Interpreter</a></h1>
<p><strong>Compiler</strong></p>
<p>The compiler scans the entire source code and translates the whole of it into machine code at once.</p>
<p>The code you write is usually converted into another form that a computer knows how to run. This process is called compilation, and the period this happens is called "<strong>compile time.</strong>"</p>
<p>After compilation, the program is launched, and the period it's running is called "<strong>runtime.</strong>"</p>
<p>Types of programming languages that use compilers are</p>
<p>C</p>
<p>C++</p>
<p>Rust</p>
<p>Haskell</p>
<p>Erlang</p>
<p><strong>Interpreters</strong></p>
<p>The Interpreter translates just one statement of the source code at a time into machine code at runtime.</p>
<p>Type of programming languages that use interpreters are</p>
<p>Python</p>
<p>PHP</p>
<p>Perl</p>
<p>Ruby</p>
<p><strong>What about JAVA?</strong></p>
<p>The JAVA is a combination of both.</p>
<p>It first compiles the source code into byte code and uses Java Virtual Machine (JVM) to interpret the Java byte code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-vs-dynamic"><a class="header" href="#static-vs-dynamic">Static vs Dynamic</a></h1>
<p><strong>Statically typed</strong> languages check the types and look for type errors during compile time.</p>
<p>Static type means checking for types before running the program. This lets the compiler decide whether a given variable can perform the requested actions. </p>
<p>Explicit variable-type declarations are usually required.</p>
<p>It is easy to catch errors during development. </p>
<pre><code>int a = "Hello";
</code></pre>
<p>The above statement will result in an error during compile time itself.</p>
<p>Popular languages that are statically typed are</p>
<p>C/C++/GO/Haskell/JAVA/SCALA/RUST</p>
<p><strong>Dynamically typed</strong> languages check the types and look for type errors during runtime.</p>
<p>Dynamic type means checking for types while running the program. It is risky when an application fails in production.</p>
<p>Explicit declarations are not required.</p>
<p>Variable assignments are dynamic and can be altered. (to some degree)</p>
<p>Popular languages that are dynamically typed are</p>
<p>Python/Ruby/Erlang/Javascript/PHP/Perl</p>
<p>Simple Python example</p>
<p><img src="chapter1/programming/../.gitbook/assets/image.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strongly-typed-vs-weakly-typed"><a class="header" href="#strongly-typed-vs-weakly-typed">Strongly Typed vs Weakly Typed</a></h1>
<p><strong>Strongly typed</strong> languages don't allow implicit conversions between unrelated types.</p>
<p>You usually can't perform operations on incompatible types without explicit conversion in a strongly typed language. Python is strongly typed despite being dynamically typed.</p>
<p>For example, Python is <em>a strongly-typed language</em></p>
<pre><code>#Python

a = 21;            #type assigned as int at runtime.
a = a + "dot";   #type-error, string and int cannot be concatenated.
print(a);
</code></pre>
<figure><img src="chapter1/programming/../.gitbook/assets/strongly_typed.png" alt=""><figcaption></figcaption></figure>
<p><strong>Weakly typed</strong> languages make conversions between unrelated types implicitly.</p>
<p>Similarly, Javascript is a weakly-type language.</p>
<pre><code>/*
As Javascript is a weakly-typed language, it allows implicit conversion
between unrelated types.
*/

a = 21;             
a = a + "dot";
console.log(a);
</code></pre>
<figure><img src="chapter1/programming/../.gitbook/assets/weakly_typed.png" alt=""><figcaption></figcaption></figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-matrix"><a class="header" href="#programming-matrix">Programming Matrix</a></h1>
<p><strong>Can you spot Rust in this?</strong></p>
<figure><img src="chapter1/programming/../.gitbook/assets/programming_matrix.png" alt=""><figcaption><p>Image Source : Mayank Bhatnagar</p></figcaption></figure>
<p>Rust is both strongly typed and statically typed:</p>
<ul>
<li><strong>Strongly Typed</strong>: Without explicit conversion, you can't perform operations on incompatible types.</li>
<li><strong>Statically Typed</strong>: The variable type is known at compile-time, not runtime.</li>
</ul>
<pre><code>let num = 5;
let text = "hello";

// The next line won't compile
// let result = num + text; // Error
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-overview"><a class="header" href="#rust-overview">Rust Overview</a></h1>
<ul>
<li><a href="chapter1/rust-overview/rust-overview.html">Overview</a></li>
<li><a href="chapter1/rust-overview/rust-is-used-for.html">Uses Cases</a></li>
<li><a href="chapter1/rust-overview/commonly-used-attributes.html">Commonly Used Attributes</a></li>
<li><a href="chapter1/rust-overview/playground-demo.html">Playground - Demo</a></li>
<li><a href="chapter1/rust-overview/rust-installation.html">Rust Installation</a></li>
<li><a href="chapter1/rust-overview/vs-code.html">VS Code</a></li>
<li><a href="chapter1/rust-overview/cargo.html">Cargo</a></li>
<li><a href="chapter1/rust-overview/cargo.toml.html">Cargo.toml</a></li>
<li><a href="chapter1/rust-overview/cargo.lock.html">Cargo.lock</a></li>
<li><a href="chapter1/rust-overview/cargo-example.html">Cargo Example</a></li>
<li><a href="chapter1/rust-overview/cargo-dependency-versions.html">Cargo Dependency Versions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-overview-1"><a class="header" href="#rust-overview-1">Rust Overview</a></h1>
<p>"Rust deals with low-level details of memory management, data representation, and concurrency."</p>
<h3 id="what-is-rust"><a class="header" href="#what-is-rust">What is RUST?</a></h3>
<ul>
<li>A <em>Mozilla</em> employee, Graydon Hoare, started working on a language as a personal project.</li>
<li>Later, <em>Mozilla</em> sponsored the project in 2009 and announced it in 2010.</li>
<li>The first stable release was on <em><strong>May 15, 2015</strong></em>.</li>
</ul>
<p>Rust is a <em>system programming</em> language that is safe and concurrent.</p>
<p>Many languages inspire Rust, such as</p>
<ul>
<li>System Programming Languages (C, C++)</li>
<li>Functional Programming Languages (Haskell, Erlang)</li>
</ul>
<h3 id="why-rust"><a class="header" href="#why-rust">Why Rust</a></h3>
<p><strong>Open Source</strong>: Larger community, nightly builds, adoption by big companies.</p>
<p><strong>Reliability</strong>: Rust is reliable because its model allows you to eliminate a wide range of memory-related bugs at compile time.</p>
<p><strong>Type Safe</strong>: The compiler assures that no operation will be applied to a variable of the wrong type.</p>
<p><strong>Memory Safe</strong>: Rust pointers (references) always refer to valid memory.</p>
<p><strong>Data Race Free</strong>: Rust's borrow checker guarantees thread safety by ensuring, that multiple parts of a program can't mutate the same value at the same time.</p>
<p><strong>Speed</strong>:  Rust is fast and memory-efficient. It can power production services, run on embedded devices, and easily interact with other languages because it has no runtime or garbage collector.</p>
<p><strong>Targets Bare metal</strong>: Rust can target embedded and "bare metal" programming, making it suitable to write an OS kernel or device driver. </p>
<p><strong>Security:</strong> Rust is one of the safest programming languages because it emphasizes memory safety by analyzing a program’s memory compilation at build time, preventing bugs and memory errors caused by poor memory management.</p>
<p><strong>Efficiency:</strong> Rust’s efficiency stems from its ability to assist developers in writing performance code quickly due to its very minimal and optimal runtime.</p>
<p><strong>Productivity:</strong> The Rust programming language boosts developer productivity by allowing them to create highly resilient applications.</p>
<p><strong>Safety</strong>: Ensures memory safety without the need for garbage collection. It ensures memory safety using ownership and its borrowing concept.</p>
<p><strong>Cargo Manager</strong>: It's the package manager for Rust. It's similar to npm, pip.</p>
<p><strong>Error Messages</strong>: Powerful compiler with useful error messages. it not only displays the line which has the error but, also the type of error.</p>
<p><strong>Efficient C Binding</strong>: The Rust language can interoperate with the C language. It provides a foreign function interface to communicate with C API’s. Due to its ownership rules, it can guarantee memory safety.</p>
<h3 id="stackoverflow-2022-survey"><a class="header" href="#stackoverflow-2022-survey"><strong>Stackoverflow 2022 Survey</strong></a></h3>
<figure><img src="chapter1/rust-overview/.gitbook/assets/stackoverflow_rust (1).png" alt=""><figcaption><p><a href="https://survey.stackoverflow.co/2022/#technology-most-loved-dreaded-and-wanted"><strong>https://survey.stackoverflow.co/2022/#technology-most-loved-dreaded-and-wanted</strong></a></p></figcaption></figure>
<h3 id="what-is-rust-used-for"><a class="header" href="#what-is-rust-used-for">What Is Rust Used For? <a href="chapter1/rust-overview/rust-overview.html#what-is-rust-used-for" id="what-is-rust-used-for"></a></a></h3>
<p>Rust is fit for:</p>
<ul>
<li>building powerful web applications</li>
<li>embedded systems programming</li>
<li>building distributed online services</li>
<li>cross-platform command line support</li>
</ul>
<h3 id="who-uses-rust"><a class="header" href="#who-uses-rust">Who Uses Rust?</a></h3>
<p>Some of the top companies listed here</p>
<ul>
<li>Drop Box</li>
<li>Facebook</li>
<li>Microsoft</li>
<li>Discord</li>
<li>Cloudflare</li>
<li>Coursera</li>
<li>Firefox</li>
<li>Atlassian</li>
<li>Amazon's Firecracker</li>
<li>Databricks</li>
</ul>
<p><strong>Rust is self-hosted, meaning the Rust compiler is written in Rust.</strong></p>
<p>The initial release was written using OCaml (General purpose programming language)</p>
<figure><img src="chapter1/rust-overview/.gitbook/assets/00_rust_prospects.png" alt=""><figcaption></figcaption></figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-is-used-for"><a class="header" href="#rust-is-used-for">Rust is used for...</a></h1>
<figure><img src="chapter1/rust-overview/.gitbook/assets/Rust_Programming_Categories.png" alt=""><figcaption><p>Src: Unknown</p></figcaption></figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commonly-used-attributes"><a class="header" href="#commonly-used-attributes">Commonly Used Attributes</a></h1>
<p>Don't worry if these things don't make sense; we will learn all these things in the coming weeks.</p>
<p>#[allow(unused_variables, unused_mut)] - Unused Variables</p>
<p>#[allow(dead_code)] - Used with Functions </p>
<p>#[test] - Unit Test Cases</p>
<p>#[ignore] - Ignore Test</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="playground"><a class="header" href="#playground">Playground</a></h1>
<p>If you just want to try a bit of Rust code or check the syntax for a definition in a Rust library. You might also be looking for a way to share some code with others.</p>
<p>The Rust language offers support for these tasks in the Rust playground.</p>
<p><a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a></p>
<p>In the playground, you can access methods and functions in the Rust std standard library.</p>
<p>The top 100 most-downloaded crates in the crates.io library are also available along with their dependencies.</p>
<hr />
<h2 id="demo"><a class="header" href="#demo">Demo</a></h2>
<p>Let's try with a simple example.</p>
<pre><pre class="playground"><code class="language-rust">fn main(){println!(Welcome to Rust!);}</code></pre></pre>
<figure><img src="chapter1/rust-overview/../../assets/image (5).png" alt=""><figcaption>Image Src: Microsoft Rust Documentation</figcaption></figure>
<p>The tool adjusts the code to follow official Rust styles:</p>
<figure><img src="chapter1/rust-overview/../../assets/image (2).png" alt=""><figcaption>Image Src: Microsoft Rust Documentation</figcaption></figure>
<p>Select <strong>Tools</strong> &gt; <strong>Clippy</strong> to check for mistakes in the code. The results are displayed under the editor:</p>
<figure><img src="chapter1/rust-overview/../../assets/image (6).png" alt=""><figcaption>Image Src: Microsoft Rust Documentation</figcaption></figure>
<p>To fix the sample code, add quote marks around the text "Welcome to Rust!":</p>
<figure><img src="chapter1/rust-overview/../../assets/image (3).png" alt=""><figcaption>Image Src: Microsoft Rust Documentation</figcaption></figure>
<p>Now we'll compile the code and run the program.</p>
<p>Image Src: Microsoft Rust Documentation</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-installation"><a class="header" href="#rust-installation">Rust Installation</a></h1>
<h2 id="mac"><a class="header" href="#mac">MAC</a></h2>
<pre><code>// install rustup 

// more details https://www.rust-lang.org/tools/install

# curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

// Verify the installation

# rustc --version

# cargo --version
</code></pre>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>Download the installer from this URL and execute the file.</p>
<pre><code>https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-gnu/rustup-init.exe
</code></pre>
<p><strong>Step 1</strong>: Type 1 and hit enter</p>
<figure><img src="chapter1/rust-overview/../../assets/rust_01.png" alt=""><figcaption></figcaption></figure>
<p><strong>Step 2</strong>: Setup will download and install Visual Studio Installer. It doesn't matter even if you have VS Code, as this is a different installer. </p>
<figure><img src="chapter1/rust-overview/../../assets/rust_02.png" alt=""><figcaption></figcaption></figure>
<p><strong>Step 3</strong>: Check the components and click Install.</p>
<p>Note: Based on the version of your windows, the screen will display the appropriate version number.</p>
<figure><img src="chapter1/rust-overview/../../assets/rust_03.png" alt=""><figcaption></figcaption></figure>
<p><strong>Step 4:</strong> Type 1 and press Enter to proceed with default installation. If you want to customize then type 2 and press Enter.</p>
<figure><img src="chapter1/rust-overview/../../assets/rust_04.png" alt=""><figcaption></figcaption></figure>
<p><strong>Step 5</strong>: If you had chosen option 2, then confirm your settings and type 1 to proceed with the installation.</p>
<figure><img src="chapter1/rust-overview/../../assets/rust_05.png" alt=""><figcaption></figcaption></figure>
<p>Step 6: Goto Command prompt (Start &gt; Run &gt; cmd)</p>
<p>type </p>
<pre><code>C:\&gt; rustc --version

C:\&gt; cargo --version
</code></pre>
<p>To verify the rust installation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h1>
<p>Download and Install  VS Code. (This is different from Visual Studio)</p>
<p>{% embed url="https://code.visualstudio.com/" %}</p>
<h3 id="windows-users"><a class="header" href="#windows-users">Windows Users</a></h3>
<p>Create a new folder on your c:\</p>
<p>Let's call it</p>
<p><strong>c:\learning\rustpgm</strong>  </p>
<p><strong>Open VS Code</strong></p>
<p>Goto File &gt; Add Folder to Workspace</p>
<p>Choose  c:\learning\rustpgm and click Add</p>
<p>Click Trust / Ok if it prompts.</p>
<p>Goto File &gt; Save Workspace and save the workspace as <strong>rustpgm.code-workspace</strong></p>
<p>Right-click on rustpgm and choose New File</p>
<p>Name the file as 01.rs</p>
<p>Copy the sample rust code</p>
<pre><code>// Sample Code

fn main(){
    println!("Hello World");
}

</code></pre>
<p>Save the Script (press Ctrl + S  or File &gt; Save)</p>
<p><strong>Click New Terminal</strong></p>
<p>Make sure you are in this folder  c:\learning\rustpgm</p>
<p>type</p>
<p><strong>rustc 01.rs</strong></p>
<p>once compilation is done.</p>
<p>Verify  the result by listing the file contents</p>
<p><strong>dir</strong></p>
<p>Execute the program by typing the following</p>
<p><strong>./01.exe</strong></p>
<h3 id="mac-users"><a class="header" href="#mac-users">Mac Users</a></h3>
<p>Create a new folder on your Documents folder</p>
<p>Let's call it</p>
<p><strong>/Documents/learning/rustpgm</strong>  </p>
<p><strong>Open VS Code</strong></p>
<p>Goto File &gt; Add Folder to Workspace</p>
<p>Choose  /Documents/learning/rustpgm and click Add</p>
<p>Click Trust / Ok if it prompts.</p>
<p>Goto File &gt; Save Workspace and save the workspace as <strong>rustpgm.code-workspace</strong></p>
<p>Right-click on rustpgm and choose New File</p>
<p>Name the file as 01.rs</p>
<p>Copy the sample rust code</p>
<pre><code>
fn main(){
    println!("Hello World");
}

</code></pre>
<p>Save the Script (press Ctrl + S  or File &gt; Save)</p>
<p><strong>Click New Terminal</strong></p>
<p>Make sure you are in this folder  Documents/learning/rustpgm</p>
<p>type</p>
<p><strong>rustc 01.rs</strong></p>
<p>once compilation is done.</p>
<p>Verify  the result by listing the file contents</p>
<p>ls</p>
<p>Execute the program by typing the following</p>
<p><strong>./01</strong></p>
<h3 id="vs-code-extensions"><a class="header" href="#vs-code-extensions">VS Code Extensions</a></h3>
<p><strong>Preferred Extensions for Rust</strong></p>
<figure><img src="chapter1/rust-overview/../../assets/rust_vs_code_extensions_00.png" alt=""><figcaption></figcaption></figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<pre><code>// Cargo frequently used subcommands

cargo --help

cargo --version

cargo new projectname  //Creates project under new sub folder

cargo init projectname // Creates project under existing folder

cargo build //Compile the current package

cargo build --release

cargo run //Run the current package

cargo check //Check the current package for dependency errors

cargo fetch //Fetch dependencies of a package from the network

cargo test //Execute unit and integration tests of a package

cargo clean //Remove generated artifacts

cargo update //Update dependencies as recorded in the local lock file

cargo doc //build package's documentation

cargo fmt //format the code


</code></pre>
<p><strong>Cargo Book</strong></p>
<p>{% embed url="https://doc.rust-lang.org/cargo/commands/index.html" %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-example"><a class="header" href="#cargo-example">Cargo Example</a></h1>
<pre><code>// Some code

cargo new osinfo

cd osinfo
</code></pre>
<p>Replace the main.rs code with the code given below</p>
<pre><code>// Rust sample for displaying OS Info

fn main() {
    println!("Hello, world!");

    let info = os_info::get();

    // Print full information:
    println!("OS information: {}", info);

    // Print information separately:
    println!("Type: {}", info.os_type());
    println!("Version: {}", info.version());
    println!("Bitness: {}", info.bitness());
}

</code></pre>
<p>Run the following statements</p>
<pre><code>cargo check

cargo fetch

cargo build
</code></pre>
<p>check the executable under target/debug</p>
<pre><code>// Some code

cargo build --release
</code></pre>
<p>check the executable under target/release</p>
<p>The release executable will be smaller in size than debug executable.</p>
<p>Because, debug contains symbols &amp; backtraces</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-dependency-versions"><a class="header" href="#cargo-dependency-versions">Cargo dependency versions</a></h1>
<p>While specifying the dependency version, you can either specify the exact one or mention the bottom range number.</p>
<p>Here are some more examples of version requirements and the versions that would be allowed with them:</p>
<p>You can mention the number given on the left-hand side instead for the range of versions given on the right-hand side.</p>
<pre><code>
1.2.3  :=  &gt;=1.2.3, &lt;2.0.0
1.2    :=  &gt;=1.2.0, &lt;2.0.0
1      :=  &gt;=1.0.0, &lt;2.0.0

0.2.3  :=  &gt;=0.2.3, &lt;0.3.0
0.2    :=  &gt;=0.2.0, &lt;0.3.0
0.0.3  :=  &gt;=0.0.3, &lt;0.0.4
0.0    :=  &gt;=0.0.0, &lt;0.1.0
0      :=  &gt;=0.0.0, &lt;1.0.0

//example using wildcards

*     := &gt;=0.0.0
1.*   := &gt;=1.0.0, &lt;2.0.0
1.2.* := &gt;=1.2.0, &lt;1.3.0

// Comparison requirements

&gt;= 1.2.0
&gt; 1
&lt; 2
= 1.2.3

// Multiple dependencies separated by comma

This means the version should be greater than or equal to 1.2 and less than 1.5

&gt;= 1.2,  &lt; 1.5
</code></pre>
<p>In the previous example (Cargo Example - 2), instead of mentioning</p>
<p>os-info = "3.5.0" we have mentioned </p>
<p>os-info = "3" </p>
<p><strong>Using crate.io repositories</strong></p>
<pre><code>// Some code

[dependencies]
regex = { git = "https://github.com/rust-lang/regex" }

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="chapter1/starter-crates/README.html">Starter Crates</a>
<ul>
<li><a href="chapter1/starter-crates/basic-program.html">Basic Programs</a></li>
<li><a href="chapter1/starter-crates/comments.html">Comments</a></li>
<li><a href="chapter1/starter-crates/variables.html">Variables</a></li>
<li><a href="chapter1/starter-crates/simple-rust-programs.html">Simple Rust Programs</a></li>
<li><a href="chapter1/starter-crates/pretty-please-print.html">Pretty Print</a></li>
<li><a href="chapter1/starter-crates/escape-printing.html">Escape Printing</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-basic-program"><a class="header" href="#the-basic-program">The Basic Program</a></h1>
<p>Rust code is always put in a file with <code>.rs</code> extension</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello World!");
}</code></pre></pre>
<p><img src="chapter1/starter-crates/../../assets/01_fn_main.png" alt="Images Source: https://www.educative.io" /></p>
<p><img src="chapter1/starter-crates/../../assets/01_print_macro.png" alt="Image Source: https://www.educative.io" /></p>
<p><img src="chapter1/starter-crates/../../assets/01_macro_explanation.png" alt="Image Source: https://www.educative.io" /></p>
<p><strong>Basic Formatting</strong></p>
<p><img src="chapter1/starter-crates/../../assets/01_print_formatting.png" alt="Image Source: https://www.educative.io" /></p>
<p>In Rust, unlike other languages, we cannot directly print numbers or variables within the <br />
 macro. We need a placeholder  trait<code>{}</code>.</p>
<p>In Rust, a trait is a way to define a set of methods that can be implemented on different types.</p>
<p><strong>Positional Arguments</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Number: {}", 1);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("{} last name is {} ", "Rachel", "Green");
}</code></pre></pre>
<p><strong>Named Arguments</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("{fname} last name is {lname} ", lname="Green", fname="Rachel");
}</code></pre></pre>
<p><strong>Basic Math</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("{} * {} = {}",15, 15, 15 * 15);
}</code></pre></pre>
<p>A trait in Rust is <strong>a group of methods that are defined for a particular type.</strong></p>
<p><strong>Printing formatters</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Number : 20 \nBinary:{:b} Hexadecimal:{:x} Octal:{:o}", 20, 20, 20);
}</code></pre></pre>
<p><strong>Debug Trait {:?}</strong></p>
<p>In Rust, the <code>Debug</code> trait is a built-in trait that allows types to be formatted for debugging purposes. It is primarily used by the <code>println!</code> and related macros to print a text representation of a value when used with the <code>{:?}</code> formatter.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("{:?}", (100, "Rachel Green"));
}</code></pre></pre>
<p><strong>Printing Styles</strong></p>
<p><img src="chapter1/starter-crates/../../assets/01_printing_styles.png" alt="Source: http://www.educative.io" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>Line Comments //</p>
<p>Block Comments /*  */</p>
<p>Doc Comments</p>
<p>Outer Doc Comments ///</p>
<p>Inner Doc Comments //!</p>
<pre><pre class="playground"><code class="language-rust">// Writing a Rust program
fn main() {
    //The line comment is the recommended comment style
    println!("This is a line comment!"); // print hello World to the screen
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">/* Writing a Rust program */

/* comments can be /* nested */ too */

fn main() {
    println!("This is a line comment!");
}
</code></pre></pre>
<p>Doc Comments are used to generate Documentation and they support markdown notations</p>
<pre><pre class="playground"><code class="language-rust">/// This is a Doc comment outside the function
/// Generate docs for the following item.
/// This shows my code outside a module or a function
fn main() {
    //! This a doc comment that is inside the function   
    //! This comment shows my code inside a module or a function  
    //! Generate docs for the enclosing item
    println!("{} can support {} notation","Doc comment","markdown");
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>A variable is like a <strong>storage box</strong> paired with an <strong>associated name</strong> which contains <strong>data</strong>. The associated name is the identifier and the data that goes inside the variable is the value. They are <strong>immutable by default</strong>, meaning, you cannot reassign value to them.</p>
<p><img src="chapter1/starter-crates/../../assets/02_variable.png" alt="Images Source: https://www.educative.io" /></p>
<p>To create a variable, use the <code>let</code> binding followed by the variable name</p>
<blockquote>
<p><strong>What is binding?</strong></p>
<p>Rust refers to <strong>declarations</strong> as bindings as they bind a name at the time of creation. <strong><code>let</code></strong> is a kind of <strong>declaration statement</strong>.</p>
</blockquote>
<blockquote>
<p><strong>Naming Convention:</strong> By convention, you would write a variable name in a <strong>snake_case</strong> i.e.,</p>
<ul>
<li>All letters should be lower case.</li>
<li>All words should be separated using an underscore ( _ )</li>
</ul>
</blockquote>
<h3 id="initialize-a-variable"><a class="header" href="#initialize-a-variable">Initialize a variable</a></h3>
<p>A variable can be initialized by assigning a value to it when it is declared. The value is said to be bound to that variable.</p>
<p><strong>Note:</strong> It’s possible to declare the variable first and assign it a value later. However, it is not recommended to do this as it may lead to the use of uninitialized variables.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let language = "Rust"; // define a variable
    println!("Language: {}", language); // print the variable
}</code></pre></pre>
<p>Note: it is not possible to directly print a variable within a <code>println!()</code>. You need a placeholder.</p>
<h3 id="how-to-create-a-mutable-variable"><a class="header" href="#how-to-create-a-mutable-variable">How to create a Mutable Variable</a></h3>
<pre><code>let mut variable = "value"
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut language = "Rust"; // define a mutable variable
    println!("Language: {}", language); // print the variable
    language = "Java"; // update the variable
    println!("Language: {}", language); // print the updated value of variable
}</code></pre></pre>
<h3 id="assigning-multiple-values"><a class="header" href="#assigning-multiple-values">Assigning Multiple Values</a></h3>
<pre><code>let (variable1,variable2) = ("value1", value2);
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let (fname,lname) =("Rachel","Green"); // assign multiple values
    println!(" Student Name is {} {}.", fname,lname); // print the value
}</code></pre></pre>
<p>If variables are unassigned or unused compiler will generate warning</p>
<pre><code>#[allow(unused_variables, unused_mut)]
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let (fname,lname,mi) =("Rachel","Green",""); // assign multiple values
    println!(" Student Name is {} {}.", fname,lname); // print the value
}</code></pre></pre>
<h3 id="variable-scope"><a class="header" href="#variable-scope">Variable Scope</a></h3>
<p>The scope of a variable refers to the visibility of a variable, or, which parts of a program can access that variable.</p>
<p>It all depends on where this variable is being declared. If it is declared inside any curly braces <strong>{}</strong>, i.e., a block of code, its scope is restricted within the braces, otherwise the scope is global.</p>
<p><strong>Local Variable</strong></p>
<p>A variable that is within a block of code, <code>{ }</code>, that cannot be accessed outside that block is a local variable. After the closing curly brace, <code>}</code> , the variable is freed and memory for the variable is deallocated.</p>
<p><strong>Global Variable</strong></p>
<p>The variables that are declared outside any block of code and can be accessed within any subsequent blocks are known as global variables.</p>
<p><img src="chapter1/starter-crates/../../assets/02_variable_scope.png" alt="Images Source: https://www.educative.io" /></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let outer_variable = 112;
  { // start of code block
        let inner_variable = 213;
        println!("block variable inner: {}", inner_variable);
        println!("block variable outer: {}", outer_variable);
  } // end of code block
    println!("inner variable: {}", inner_variable); // use of inner_variable outside scope
}
</code></pre></pre>
<h3 id="how-to-fix-this-error"><a class="header" href="#how-to-fix-this-error">How to fix this error?</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let outer_variable = 112;
  let inner_variable = 213;
  { // start of code block
        println!("block variable inner: {}", inner_variable);
        println!("block variable outer: {}", outer_variable);
  } // end of code block
    println!("inner variable: {}", inner_variable);
  }
</code></pre></pre>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>Variable shadowing is a technique in which a variable declared within a certain scope has the same name as a variable declared in an outer scope. This is also known as masking. This outer variable is shadowed by the inner variable, while the inner variable is said to mask the outer variable.</p>
<p><img src="chapter1/starter-crates/../../assets/02_variable_shadowing.png" alt="Images Source: https://www.educative.io" /></p>
<pre><code>fn main() {
  let outer_variable = 112;
  { // start of code block
        let inner_variable = 213;
        println!("block variable: {}", inner_variable);
        let outer_variable = 117;
        println!("block variable outer: {}", outer_variable);
  } // end of code block
    println!("outer variable: {}", outer_variable);
  }
</code></pre>
<h3 id="another---variable-reused-in-same-scope"><a class="header" href="#another---variable-reused-in-same-scope">Another - Variable reused in same scope</a></h3>
<pre><pre class="playground"><code class="language-rust">// Shadowing

fn main() {
   let spaces = "Testing";
   println!("{:?}",spaces);
   let spaces = spaces.len();
   println!("{:?}",spaces);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-rust-programs"><a class="header" href="#simple-rust-programs">Simple Rust Programs</a></h1>
<h3 id="using-variables"><a class="header" href="#using-variables">Using Variables</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let name = "Rachel";
    let age=30;
    println!("Hello {},{}", name,age);

    //change the value of variable
    
    let name = "Rachel Green";
    println!("Hello {},{}", name,age);

}</code></pre></pre>
<h3 id="using-multiple-variables"><a class="header" href="#using-multiple-variables">Using Multiple Variables</a></h3>
<pre><pre class="playground"><code class="language-rust">#[allow(unused_variables, unused_mut)]

fn main() {
    let (fname,lname,mi) =("Rachel","Green",""); // assign multiple values
    println!(" Student Name is {} {}.", fname,lname); // print the value
}</code></pre></pre>
<h3 id="for-loops"><a class="header" href="#for-loops">FOR Loops</a></h3>
<pre><pre class="playground"><code class="language-rust">// non inclusive on right side

fn main() {
    for i in 0..5 {
        println!("Hello {}", i);
    }
}</code></pre></pre>
<h3 id="odd--even"><a class="header" href="#odd--even">ODD / EVEN</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for i in 0..5 {
        if i % 2 == 0 {
            println!("even {}", i);
        } else {
            println!("odd {}", i);
        }
    }
}</code></pre></pre>
<h4 id="alternate-method"><a class="header" href="#alternate-method">Alternate Method</a></h4>
<pre><pre class="playground"><code class="language-rust">// Expression assigned as Value

fn main() {
    for i in 0..5 {
        let even_odd = if i % 2 == 0 {"even"} else {"odd"};
        println!("{} {}", even_odd, i);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pretty-please---print"><a class="header" href="#pretty-please---print">Pretty Please - Print</a></h1>
<pre><pre class="playground"><code class="language-rust">// Print

fn main() {
    let doesnt_print = ();
    println!("This will not print: {}", doesnt_print); // ⚠️
}</code></pre></pre>
<p>Pretty Print</p>
<pre><pre class="playground"><code class="language-rust">// Pretty Print

fn main() {
    let doesnt_print = ();
    println!("This will print: {:#?}", doesnt_print); // ⚠️
}</code></pre></pre>
<p>What is the output of this?</p>
<pre><pre class="playground"><code class="language-rust">// Print Space

fn main() {
    let doesnt_print = ' ';
    println!("This will not print: {}", doesnt_print); // ⚠️
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Pretty Print Space

fn main() {
    let doesnt_print = ' ';
    println!("This will print: {:#?}", doesnt_print); // ⚠️
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escape-printing"><a class="header" href="#escape-printing">Escape Printing</a></h1>
<p>Similar to other programming languages  \t and \n are used for Tab and Newlines</p>
<pre><pre class="playground"><code class="language-rust">// \t \n

fn main() {
    print!("\t first line is tabbed \nand second line is on a new line");
}</code></pre></pre>
<h3 id="how-to-print-t-and--n"><a class="header" href="#how-to-print-t-and--n">How to print \t and  \n?</a></h3>
<pre><pre class="playground"><code class="language-rust">// Escape Characters

fn main() {
    println!("Here are two escape characters: \\n and \\t");
}</code></pre></pre>
<h3 id="print-multiple-escape-characters"><a class="header" href="#print-multiple-escape-characters">Print multiple escape characters</a></h3>
<pre><pre class="playground"><code class="language-rust">// Print multiple \\ , "

fn main() {
    println!("File \"folder location is at c:\\users\\ganesh\\Documents\\01.rs.\" ") 
}</code></pre></pre>
<p>Too many \\ there is a good chance one might forget to \\, is there an easy way?</p>
<pre><pre class="playground"><code class="language-rust">// r#  and  #  

fn main() {
    println!(r#"File "folder location is at c:\users\ganesh\Documents\01.rs." "#) 
}</code></pre></pre>
<p>If you need to print #, then use ##</p>
<pre><pre class="playground"><code class="language-rust">// # &amp; ##

fn main() {
    let hashtag_string = r##"The hashtag #IceToSeeYou had become very popular."##; // Has one # so we need at least ##
    let many_hashtags = r####""You don't have to type ### to use a hashtag. You can just use #.""####; // Has three ### so we need at least ####

    println!("{}\n{}\n", hashtag_string, many_hashtags);
}</code></pre></pre>
<h3 id="alternate-use"><a class="header" href="#alternate-use">Alternate Use</a></h3>
<p><em>Not a good programming practice to use keywords as variables</em></p>
<pre><pre class="playground"><code class="language-rust">// Using reserved words

fn main() {
    let let=4;
    println!("{}", let);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// r#

fn main() {
    let r#let=4;
    println!("{}", r#let);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2"><a class="header" href="#chapter-2">Chapter 2</a></h1>
<ul>
<li><a href="chapter2/data-types/README.html">Data Types</a>
<ul>
<li><a href="chapter2/data-types/overview.html">Overview</a></li>
<li><a href="chapter2/data-types/integer.html">Integer</a></li>
<li><a href="chapter2/data-types/floating-point.html">Floating-point</a></li>
<li><a href="chapter2/data-types/boolean.html">Boolean</a></li>
<li><a href="chapter2/data-types/char-and-strings.html">Char &amp; Strings</a></li>
<li><a href="chapter2/data-types/string-based-programs.html">String based crates</a></li>
<li><a href="chapter2/data-types/arrays.html">Arrays</a></li>
<li><a href="chapter2/data-types/tuples.html">Tuples</a></li>
<li><a href="chapter2/data-types/constants.html">Constants</a></li>
<li><a href="chapter2/data-types/unit-type.html">Unit-type</a></li>
</ul>
</li>
<li><a href="chapter2/and-and.html">Reference - Dereference</a></li>
<li><a href="chapter2/expression.html">Expressions</a></li>
<li><a href="chapter2/operators/README.html">Operators</a>
<ul>
<li><a href="chapter2/operators/binary-operators.html">Binary Operators</a></li>
</ul>
</li>
<li><a href="chapter2/flow-of-control/README.html">Flow of control</a>
<ul>
<li><a href="chapter2/flow-of-control/match.html">Match</a></li>
</ul>
</li>
<li><a href="chapter2/functions.html">Functions</a></li>
<li><a href="chapter2/unit-tests/README.html">Unit Tests</a>
<ul>
<li><a href="chapter2/unit-tests/calculator.html">Calculator</a></li>
<li><a href="chapter2/unit-tests/assert-macros.html">Assert Macros</a></li>
<li><a href="chapter2/unit-tests/control-cargo-tests.html">Cargo Test examples</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<pre><code>* [Overview](overview.md)
* [Integer](integer.md)
* [Floating-point](floating-point.md)
* [Boolean](boolean.md)
* [Char &amp; Strings](char-and-strings.md)
* [String based crates](string-based-programs.md)
* [Arrays](arrays.md)
* [Tuples](tuples.md)
* [Constants](constants.md)
* [Unit-type](unit-type.md)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types-1"><a class="header" href="#data-types-1">Data Types</a></h1>
<p>Rust is a <strong>statically typed</strong> language, meaning, it must know the type of all variables at compile time.</p>
<h2 id="variable-definition"><a class="header" href="#variable-definition">Variable Definition</a></h2>
<h3 id="implicit-definition"><a class="header" href="#implicit-definition">Implicit Definition</a></h3>
<p>Unlike other languages like C++ and Java, Rust can infer the type from the type of value assigned to a variable.</p>
<pre><code>let variablename = value
</code></pre>
<h3 id="explicit-definition"><a class="header" href="#explicit-definition">Explicit Definition</a></h3>
<pre><code>let variablename:datatype = value
</code></pre>
<p><img src="chapter2/data-types/../../assets/03_datatypes.png" alt="" /></p>
<p><img src="chapter2/data-types/../../assets/03_datatype_scalar.png" alt="" /></p>
<p><img src="chapter2/data-types/../../assets/03_datatype_compound.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer"><a class="header" href="#integer">Integer</a></h1>
<p><strong>Fixed Size Integers</strong></p>
<ul>
<li><code>i8</code>: The <strong>8-bit signed</strong> integer type.</li>
<li><code>i16</code>: The <strong>16-bit signed</strong> integer type.</li>
<li><code>i32</code>: The <strong>32-bit signed</strong> integer type.</li>
<li><code>i64</code>: The <strong>64-bit signed</strong> integer type.</li>
<li><code>u8</code>: The <strong>8-bit unsigned</strong> integer type.</li>
<li><code>u16</code>: The <strong>16-bit unsigned</strong> integer type.</li>
<li><code>u32</code>: The <strong>32-bit unsigned</strong> integer type.</li>
<li><code>u64</code>: The <strong>64-bit unsigned</strong> integer type.</li>
</ul>
<p><strong>Variable Size Integers</strong></p>
<p>The integer type in which the particular size depends on the underlying machine architecture.</p>
<ul>
<li><code>isize</code>: The <strong>pointer-sized signed</strong> integer type.</li>
<li><code>usize</code>: The <strong>pointer-sized unsigned</strong> integer type.</li>
</ul>
<pre><code>// see the smallest and biggest numbers,you can use MIN and MAX 
// after the name of the type

fn main() {
    println!("The smallest i8 is {} and the biggest i8 is {}.", i8::MIN, i8::MAX); // hint: printing std::i8::MIN means "print MIN inside of the i8 section in the standard library"
    println!("The smallest u8 is {} and the biggest u8 is {}.", u8::MIN, u8::MAX);
    println!("The smallest i16 is {} and the biggest i16 is {}.", i16::MIN, i16::MAX);
    println!("The smallest u16 is {} and the biggest u16 is {}.", u16::MIN, u16::MAX);
    println!("The smallest i32 is {} and the biggest i32 is {}.", i32::MIN, i32::MAX);
    println!("The smallest u32 is {} and the biggest u32 is {}.", u32::MIN, u32::MAX);
    println!("The smallest i64 is {} and the biggest i64 is {}.", i64::MIN, i64::MAX);
    println!("The smallest u64 is {} and the biggest u64 is {}.", u64::MIN, u64::MAX);
    println!("The smallest i128 is {} and the biggest i128 is {}.", i128::MIN, i128::MAX);
    println!("The smallest u128 is {} and the biggest u128 is {}.", u128::MIN, u128::MAX);

}

</code></pre>
<h3 id="explicit-declaration"><a class="header" href="#explicit-declaration">Explicit Declaration</a></h3>
<pre><code>fn main() {
    //explicitly define an integer
    let a:i32 = 24;
    let b:u64 = 23;
    let c:u8 = 26;
    let d:i8 = 29;
    //print the values
    println!("a: {}", a);
    println!("b: {}", b);
    println!("c: {}", c);
    println!("d: {}", d);
    
}
</code></pre>
<h3 id="alternate-way-to-declare"><a class="header" href="#alternate-way-to-declare">Alternate Way to Declare</a></h3>
<pre><code>// Alternate Way

fn main() {
    let small_number: u8 = 10;
    
    let small_number1 = 10u8; // 10u8 = 10 of type u8 (no space inbetween 10 and u8)
    
    let big_number = 100000000i32;
    
    let big_number1 = 100_000_000i32; // adds clarity to numbers
 
     let big_number2 = 100_____000________000i32;  //to demonstrate multiple ___
    
}
</code></pre>
<h3 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h3>
<pre><code>fn main() {
    //implicitly define an integer
    let a = 21; 
    let b = 1;
    let c = 54;
    let d = 343434;
    //print the variable
    println!("a: {}", a);
    println!("b: {}", b);
    println!("c: {}", c);
    println!("d: {}", d);
    
}
</code></pre>
<p><strong>When not declared, the Default integer type inferred by Rust is i32</strong></p>
<pre><code>// 

fn print_type_of&lt;T&gt;(_: &amp;T) {
    println!("{}", std::any::type_name::&lt;T&gt;())
}

fn main() {
    let a = 5;
    let b = 3.14;
    print_type_of(&amp;a);
    print_type_of(&amp;b);
}    
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floating-point"><a class="header" href="#floating-point">Floating Point</a></h1>
<p>Floats are numbers with decimal points.</p>
<ul>
<li><code>f32</code>: The <strong>32-bit floating point</strong> type.</li>
<li><code>f64</code>: The <strong>64-bit floating point</strong> type.</li>
</ul>
<p>It doesn't support 16 or 128</p>
<pre><code> fn main() {
    //explicitly define a float type
    let f1:f32 = 32.9;
    let f2:f64 = 6789.89;
    let f3:fsize = 3.141414141414;
    println!("f1: {}", f1);
    println!("f2: {}", f2);
    println!("f3: {}", f3);
    
    //implicitly define a float type
    let pi = 3.14;
    let e = 2.17828;
    println!("pi: {}", pi);
    println!("e: {}", e);
}
</code></pre>
<p>Values are the same, but they are not equal. </p>
<pre><code>// Adding f32 + f64

fn main() {
    let my_float: f64 = 5.0; // This is an f64
    let my_float2: f32 = 5.0; // This is an f32

    let my_float3 = my_float + my_float2;️
    println!("{}",my_float3);
}
</code></pre>
<p>So how to fix it?</p>
<pre><code>// Adding f32 + f64 the right way

fn main() {
    let my_float: f64 = 5.0; // This is an f64
    let my_float2: f32 = 5.0; // This is an f32

    let my_float3 = my_float + my_float2 as f64;
    println!("{}",my_float3);
}
</code></pre>
<p><strong>If not declared, the Default type is f64</strong></p>
<pre><code>// What is size of my_other_float variable?
// Adding f32 with f64 will it work or fail?
// Rust is smart, 
// since it is doing addition with f32, it will default it to f32 instead of f64

fn main() {
    let my_float: f32 = 5.0;
    let my_other_float = 8.5; 

    let third_float = my_float + my_other_float;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolean"><a class="header" href="#boolean">Boolean</a></h1>
<p>true</p>
<p>false</p>
<pre><code>fn main() {
    //explicitly define a bool
    let is_bool:bool = true;
    println!("explicitly_defined: {}", is_bool);
    
    // implicit
    let a = true;
    let b = false;
    println!("a: {}", a);
    println!("b: {}", b);

}

</code></pre>
<p><strong>Expression result</strong></p>
<pre><code>fn main() {
    // get a value from an expression
    let c = 10 &gt; 2;
    println!("c: {}", c);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="char--strings"><a class="header" href="#char--strings">Char &amp; Strings</a></h1>
<p>The value assigned to a char variable is enclosed in a single quote(<code>''</code>) .</p>
<p><strong>Unlike some other languages, a character in Rust takes up 4 bytes rather than a single byte</strong>. It does so because it can store a lot more than just an ASCII value like emojis, Korean, Chinese, and Japanese characters.</p>
<pre><code>fn main() { 
    // implicitly &amp; explicitly define
    let char_2:char = 'a';
    let char_3 = 'b';
    println!("character2: {}", char_2);
    println!("character3: {}", char_3);
}
</code></pre>
<h3 id="string-literal"><a class="header" href="#string-literal"><strong>String Literal</strong></a></h3>
<p>Used when the value of the string is known at compile time. Literals are set of characters that are hardcoded to a variable at compile time. String literals are found in the module <code>std::str</code></p>
<p>String literals are stored in the Stack portion of the memory so retrieval is fast.</p>
<pre><code>fn main() {
    // explicitly define 
    let str_1:&amp;str = "Rust Programming";
    println!("String 1: {}", str_1);
 
    // implicitly define
    let str_2 = "Rust Programming";
    println!("String 2: {}", str_2);
}

</code></pre>
<h3 id="string-object"><a class="header" href="#string-object">String Object</a></h3>
<p>String objects are dynamic and can be changed during runtime.</p>
<p>A String object is allocated in the heap memory. Its slower but has more features.</p>
<p>String::new() - Creates an empty string.</p>
<p>String::from() - Default value passed as parameter.</p>
<pre><code>fn main(){
   let empty_string = String::new();
   println!("length is {}",empty_string.len());

   let content_string = String::from("Rachel Green");
   println!("length is {}",content_string.len());
}
</code></pre>
<p>String Operations</p>
<p>variable.push() - to push a single character</p>
<pre><code>// Push Single Character

fn main(){
   let mut name1 = String::from("Hello");
   println!("{}",name1);
   name1.push('!');
   println!("{}",name1);
}
</code></pre>
<p>variable.push_str() - to push a set of characters</p>
<pre><code>// Push a string

fn main(){
   let mut name1 = String::from("Hello");
   println!("{}",name1);
   name1.push_str("World");
   println!("{}",name1);
}
</code></pre>
<p>variable.replace("","")</p>
<pre><code>fn main(){
   let name1 = String::from("Hello!");
   let name2 = name1.replace("Hello","Howdy");    //find and replace
   println!("{}",name2);
}
</code></pre>
<p><strong>Convert String Literal to String Object (to_string())</strong></p>
<pre><code>
fn main(){
   let name1 = "Hello!".to_string();              //String object
   let name2 = name1.replace("Hello","Howdy");    //find and replace
   println!("{}",name2);
}
</code></pre>
<p><strong>Convert String Object to String Literal (as_str())</strong></p>
<pre><code>fn main() {
    let name1 = String::from("hello");
    let name2 = name1.as_str();
    println!("{},{}", name1, name2);
}
</code></pre>
<h3 id="script-to-find-the-data-type"><a class="header" href="#script-to-find-the-data-type">Script to find the data type</a></h3>
<pre><code>fn print_type_of&lt;T&gt;(_: &amp;T) {
    println!("{}", std::any::type_name::&lt;T&gt;())
}

fn main() {
    let name = "StringSample";
    let name1 = String::from("Hello");
    print_type_of(&amp;name);
    print_type_of(&amp;name1);
}    
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-based-programs"><a class="header" href="#string-based-programs">String based programs</a></h1>
<p>Assignment - Explain the logic behind these working examples.</p>
<p>For example, you need to explain why &amp;str2 ? why not str2.</p>
<p>what is the use of collect()</p>
<h3 id="concatenation"><a class="header" href="#concatenation">Concatenation</a></h3>
<pre><code>// concatenation

fn main() {
  let str1 = "Hello".to_string();
  let str2 = " world".to_string();
  let string = str1 + &amp;str2;
  println!("{}", string);
}
</code></pre>
<h3 id="string-reverse"><a class="header" href="#string-reverse">String Reverse</a></h3>
<pre><code>// Reverse String

fn main() {
    let s = "Hello World";
    let t: String = s.chars().rev().collect();
    println!("{}", t);
}

</code></pre>
<h3 id="check-palindrome"><a class="header" href="#check-palindrome">Check Palindrome</a></h3>
<pre><code>// Palindrome

fn main() {
    let s = "rotator";
    let t: String = s.chars().rev().collect();
    
    if s == t {
        println!("Palindrome")
    }
    else{
        println!("Not Palindrome")
    }
}
</code></pre>
<h3 id="string-padding"><a class="header" href="#string-padding">String Padding</a></h3>
<pre><code> // String Padding

fn main() {
    let s = "pizza";
    
    println!("{s:-^30}");
    println!("{s:*&lt;30}");
    println!("{s:#&gt;30}");
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p><strong>Arrays</strong></p>
<p>An array is a <strong>homogenous sequence of elements</strong>. </p>
<p>A Collection of values of the same type is to be stored in a single variable. </p>
<p>Fixed length &amp; Length known at compile time.</p>
<p>By default, the first element is always at index 0.</p>
<p><img src="chapter2/data-types/../.gitbook/assets/04_arrays.png" alt="" /></p>
<p>By default, arrays are immutable.</p>
<figure><img src="chapter2/data-types/../.gitbook/assets/04_arrays_definition.png" alt=""><figcaption><p><strong>Src:Educative.io</strong></p></figcaption></figure>
<p><strong>Define an Array</strong></p>
<pre><code>#[allow(unused_variables, unused_mut)]
fn main() {
   //define an array of size 4
   let arr:[i32;4] = [1, 2, 3, 4]; 
   // initialize an array of size 4 with 0
   let arr1 = [0 ; 4]; 
}
</code></pre>
<p><strong>Access Array element</strong></p>
<pre><code>fn main() {
   //define an array of size 4
   let arr:[i32;4] = [1, 2, 3, 4]; 
   //print the first element of array
   println!("The first value of array is {}", arr[0]);
   // initialize an array of size 4 with 0
   let arr1 = [10; 14]; 
   //print the first element of array
   println!("The first value of array is {}", arr1[0]);
}
</code></pre>
<p><strong>Mutable Arrays</strong></p>
<pre><code>fn main() {
    //define a mutable array of size 4
    let mut arr:[i32;4] = [1, 2, 3, 4]; 
    println!("The value of array at index 1: {}", arr[1]);
    arr[1] = 9;
    println!("The value of array at index 1: {}", arr[1]);
}
</code></pre>
<p><strong>Print Array</strong></p>
<p>Using Loop or using debug trait</p>
<pre><code>fn main() {
    //define an array of size 4
    let arr:[i32;4] = [1, 2, 3, 4]; 
    //Using debug trait
    println!("\nPrint using a debug trait");
    println!("Array: {:?}", arr);
}
</code></pre>
<p><strong>Get Array Length</strong></p>
<pre><code>fn main() {
    //define an array of size 4
    let arr:[i32;4] = [1, 2, 3, 4]; 
    // print the length of array
    println!("Length of array: {}", arr.len());
}

</code></pre>
<p><strong>Slice</strong></p>
<p>Slice is basically a portion of an array. It lets you refer to a subset of a contiguous memory location. But unlike an array, the size of the slice is not known at compile time.</p>
<p>A slice is a two-word object, the first word is a data pointer and the second word is a slice length.</p>
<p>Data pointer is a programming language object that points to the memory location of the data, i.e., it stores the memory address of the data.</p>
<p><img src="chapter2/data-types/../.gitbook/assets/04_array_slice.png" alt="" /></p>
<pre><code>fn main() {
    //define an array of size 4
    let arr:[i32;4] = [1, 2, 3, 4]; 
    //define the slice
    let slice_array1:&amp;[i32] = &amp;arr;
    let slice_array2:&amp;[i32] = &amp;arr[0..2];
    let slice_array2:&amp;[i32] = &amp;arr[0..];
    // print the slice of an array
    println!("Slice of an array: {:?}", slice_array1);
    println!("Slice of an array: {:?}", slice_array2);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>Tuples are <strong>heterogeneous sequences of elements</strong>, meaning, each element in a tuple can have a different data type. Just like arrays, tuples are of a fixed length.</p>
<p><img src="chapter2/data-types/../.gitbook/assets/04_tuple.png" alt="" /></p>
<p><strong>Define a Tuple</strong></p>
<p>A tuple can be defined by writing <code>let</code> followed by the name of the tuple and then enclosing the values within the parenthesis.</p>
<p><strong>Implicit Inference</strong></p>
<p><img src="chapter2/data-types/../.gitbook/assets/04_tuple_simple.png" alt="" /></p>
<p><strong>Explicit Inference</strong></p>
<p><img src="chapter2/data-types/../.gitbook/assets/04_tuple_w_datatype.png" alt="" /></p>
<pre><code>#[allow(unused_variables, unused_mut)]
fn main() {
    //define a tuple
    let person_data = ("Rachel", 30, "50kg", "5.4ft");
    // define a tuple with type annotated
    let person_data2 : (&amp;str, i32, &amp;str, &amp;str) = ("Ross", 31, "55kg", "5.8ft");
    
    println!("{}",person_data.0);
    println!("{}",person_data.1);
    println!("{}",person_data2.0);
}
</code></pre>
<p>Assign Tuple value to individual variables</p>
<pre><code>#[allow(unused_variables, unused_mut)]
fn main() {
    //define a tuple
    let person_data = ("Rachel", 30, "50kg", "5.4ft");
    
    let (name,age,wt,ht) = person_data;
    
    println!("{}",name);
    println!("{}",age);
    println!("{}",wt);
    println!("{}",ht);
}
</code></pre>
<p><strong>Mutable Tuples</strong></p>
<pre><code>fn main() {
    //define a tuple
    let mut person_data = ("Rachel", 30, "50kg", "5.4ft");
    //print the value of tuple
    println!("The value of the tuple at index 0 and index 1 are {} {}", person_data.0, person_data.1);
    //modify the value at index 0
    person_data.0 = "Monica";
    //print the modified value
    println!("The value of the tuple at index 0 and index 1 are {} {}", person_data.0, person_data.1);
}
</code></pre>
<p><strong>Print using Debug Trait</strong></p>
<pre><code>fn main() {
    //define a tuple
    let mut person_data = ("Rachel", 30, "50kg", "5.4ft");
    //print the value of tuple
    println!("Tuple - Person Data : {:?}", person_data);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p>Constant variables are ones that are declared constant throughout the program scope, meaning, their value cannot be modified. They can be defined in the global and local scope.</p>
<p>All letters should be UPPER CASE and words separated by underscore (_)</p>
<p><strong>Example:</strong></p>
<p>ID_1</p>
<p>ID_2</p>
<pre><code>const ID_1: i32 = 4; // define a global constant variable

fn main() {
    const ID_2: u32 = 3; // define a local constant variable
    println!("ID:{}", ID_1); // print the global constant variable
    println!("ID:{}", ID_2); // print the local constant variable
}
</code></pre>
<p>How is it different from let immutable variables</p>
<div class="table-wrapper"><table><thead><tr><th>Const</th><th>Immutable Let</th></tr></thead><tbody>
<tr><td>declared using const</td><td>declaured using let</td></tr>
<tr><td>mandatory to define the data type</td><td>data type declaration is optional</td></tr>
<tr><td>The Value of const is set before running the program</td><td>Variable can store the result at runtime</td></tr>
<tr><td>Const cannot be shadowed</td><td>let can be shadowed</td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="unit-type"><a class="header" href="#unit-type">Unit Type</a></h1>
<p>The () type, also called “unit”. The () type has exactly one value () , and is used when there is no other meaningful value that could be returned.</p>
<p><strong>The empty tuple type, () , is called “unit”, and serves as Rust's void type</strong> (unlike void , () has exactly one value, also named () , which is zero-sized).</p>
<p><strong>Example 1</strong></p>
<pre><code>fn main() {
    let my_tuple = (42, "hello", ());
    println!("Tuple: {:?}", my_tuple);
}

</code></pre>
<p>In this example, the tuple <code>my_tuple</code> contains an integer, a string, and a unit type <code>()</code>. When you run the code, it will print:</p>
<pre><code>Tuple: (42, "hello", ())
</code></pre>
<p><strong>Example 2</strong></p>
<pre><code>fn main() {
    let result = do_nothing();
    println!("Result of do_nothing: {:?}", result);
}

fn do_nothing() -&gt; () {
    // This function does nothing and returns unit type
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="and-"><a class="header" href="#and-">&amp; and *</a></h1>
<pre><code>&amp; - Reference

* - Dereference
</code></pre>
<pre><code>// &amp; and *
</code></pre>
<pre><code>// Reference and Dereference

fn main() {
    let a = 10;
    let b = &amp;a;
    
    //Printing the value of a and memory reference of a
    
    println!("{} - {:p}",a, &amp;a);
    
    // dereferencing b (10) and value of b (memory location of a)
    println!("{} - {:p}",*b, b);
    
    // dereferencing memory reference of a, referencing deference of b
    println!("{} - {:p}",*(&amp;a), &amp;(*b));
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expression"><a class="header" href="#expression">Expression</a></h1>
<pre><code> // Expression

fn main() {
    let x = 5u32;

    let y = {
        //demonstrate with semicolons and without semicolon
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // This expression will be assigned to `y`
        x_cube + x_squared + x
    };

    let z = {
        2 * x
    };
    
    let zz = {
        // The semicolon suppresses this expression and `()` is assigned to `z`
        2 * x;
    };

    println!("x is {:?}", x);
    println!("y is {:?}", y);
    println!("z is {:?}", z);
    println!("zz is {:?}", zz);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="description-there-are-two-major-types-of-operators"><a class="header" href="#description-there-are-two-major-types-of-operators">description: There are two major types of operators</a></h2>
<h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p><strong>Binary Operators</strong></p>
<p>Operators that deal with two operands</p>
<ul>
<li>Arithmetic Operators</li>
<li>Logical Operators</li>
<li>Comparison Operators</li>
<li>Assignment Operator</li>
<li>Compound Assignment Operator</li>
<li>Bitwise Operators</li>
<li>Typecast Operators</li>
</ul>
<p><strong>Unary Operators</strong></p>
<p>The Operators that act upon a single operand, for example, Negation Operator</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-operators"><a class="header" href="#binary-operators">Binary Operators</a></h1>
<p><strong>Arithmetic Operators</strong></p>
<p>+</p>
<p>-</p>
<p>*</p>
<p>/ (Division)</p>
<p>% (Modulus)</p>
<pre><code>// Some code

fn main() {
    let a = 4;
    let b = 3;
    
    println!("Operand 1:{}, Operand 2:{}", a , b);
    println!("Addition:{}", a + b);
    println!("Subtraction:{}", a - b);
    println!("Multiplication:{}", a * b);
    println!("Division:{}", a / b);
    println!("Modulus:{}", a % b);
}
</code></pre>
<p><strong>Logical Operators</strong></p>
<p>&amp;&amp; (AND Operator)</p>
<p>|| (OR Operator)</p>
<p>! (Not Operator)</p>
<p>AND and OR are known as <strong>LAZY Boolean expressions</strong>. </p>
<p>LHS is evaluated first, and based on the outcome RHS is evaluated.</p>
<p>In the case of AND, if LHS is False, then there is no need to evaluate the RHS.</p>
<p>In the case of OR, if LHS is True, then there is no need to evaluate the RHS.</p>
<pre><code>// Some code

fn main() {
  let a = true;
  let b = false;
  println!("Operand 1:{}, Operand 2:{}", a , b);
  println!("AND:{}", a &amp;&amp; b);
  println!("OR:{}", a || b);
  println!("NOT:{}", ! a);
}
</code></pre>
<p><strong>Comparison Operator</strong></p>
<p><strong>&gt;, &lt;, &lt;=, &gt;=, ==, !=</strong></p>
<pre><code>// Some code

fn main() {
    let a = 2;
    let b = 3;
    println!("Operand 1:{}, Operand 2:{}", a , b);
    println!("a &gt; b:{}", a &gt; b);
    println!("a &lt; b:{}", a &lt; b);
    println!("a &gt;= b:{}", a &gt;= b);
    println!("a &lt;= b:{}", a &lt;= b);
    println!("a == b:{}", a == b);
    println!("a != b:{}", a != b);
}

</code></pre>
<p><strong>Bitwise Operator</strong></p>
<p>Bitwise operators work on the binary representation of numbers. They're often used for:</p>
<ol>
<li><strong>Bit Manipulation</strong>: Flipping bits, setting bits to 1 or 0.</li>
<li><strong>Optimization</strong>: Faster arithmetic operations like multiplication or division by powers of 2.</li>
<li><strong>Masking</strong>: Extracting specific bits from a number.</li>
<li><strong>Encoding &amp; Decoding</strong>: Data compression or encryption techniques.</li>
<li><strong>Networking</strong>: IP address manipulation, subnet masking.</li>
</ol>
<pre><code>x = 57  # 0011 1001 in binary
mask = 15  # 0000 1111 in binary
result = x &amp; mask  # 0000 1001, or 9 in decimal
</code></pre>
<p><strong>Common use cases with Rust</strong></p>
<ol>
<li><strong>Memory Management</strong>: Manipulating individual bits for custom allocators.</li>
<li><strong>File I/O</strong>: Reading and writing binary files, especially in low-level systems programming.</li>
<li><strong>Graphics</strong>: Bitwise operations are used in image processing for tasks like masking.</li>
<li><strong>Cryptography</strong>: Implementing cryptographic algorithms often involves bitwise manipulation.</li>
<li><strong>Hardware Interaction</strong>: Directly interacting with hardware often requires setting specific bits.</li>
</ol>
<pre><code>fn main() {
    let mut flags = 0b0000_0101;
    let mask = 0b0000_1000;
    flags |= mask;  // Sets the bit at position 3 to 1
    println!("{}",flags);
}
</code></pre>
<p>&amp; - Bitwise AND</p>
<p>| - Bitwise OR</p>
<p>^ - Bitwise XOR</p>
<p>! - Bitwise NOT</p>
<p>&lt;&lt; - Left Shift Operator</p>
<p>&gt;&gt; - Right Shift Operator</p>
<figure><img src="chapter2/operators/../.gitbook/assets/05_bitwise_operator.png" alt=""><figcaption><p>Src: Educative.io</p></figcaption></figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-of-control"><a class="header" href="#flow-of-control">Flow of Control</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match">Match</a></h1>
<p>Match is similar to  Switch Case in  other languages.</p>
<pre><code>// Some code


fn main() {
    let number = 34;
    // TODO ^ Try different values for `number`

    println!("Tell me about {}", number);
    match number {
        // Match a single value
        1 =&gt; println!("One!"),
        // Match several values
        2 | 3 | 5 | 7 | 11 =&gt; println!("This is a prime"),
        // TODO ^ Try adding 13 to the list of prime values
        // Match an inclusive range
        13..=19 =&gt; println!("A teen"),
        // we can bind the matched number to a variable
        matched_num @ 10..=100 =&gt; {
            println!("found {} number between 10 to 100!", matched_num);
        }
        // Handle the rest of cases
        _ =&gt; println!("Ain't special"),
        // TODO ^ Try commenting out this catch-all arm
    }

    let boolean = true;
    // Match is an expression too
    let binary = match boolean {
        // The arms of a match must cover all the possible values
        false =&gt; 0,
        true =&gt; 1,
        // TODO ^ Try commenting out one of these arms
    };

    println!("{} -&gt; {}", boolean, binary);
}

</code></pre>
<h3 id="tuples-with-match"><a class="header" href="#tuples-with-match">Tuples with Match</a></h3>
<pre><code>
fn main() {
    let triple = (0, -2, 3);
    // TODO ^ Try different values for `triple`

    println!("Tell me about {:?}", triple);
    // Match can be used to destructure a tuple
    match triple {
        // Destructure the second and third elements
        (0, y, z) =&gt; println!("First is `0`, `y` is {:?}, and `z` is {:?}", y, z),
        (1, ..)  =&gt; println!("First is `1` and the rest doesn't matter"),
        (.., 2)  =&gt; println!("last is `2` and the rest doesn't matter"),
        (3, .., 4)  =&gt; println!("First is `3`, last is `4`, and the rest doesn't matter"),
        // `..` can be used to ignore the rest of the tuple
        _      =&gt; println!("It doesn't matter what they are"),
        // `_` means don't bind the value to a variable
    }
}

</code></pre>
<p> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Like other programming languages, functions are the basic building blocks of readable, maintainable, and reusable code.</p>
<p>In Rust, functions can be created before or after the main routine.</p>
<h3 id="simple-function"><a class="header" href="#simple-function">Simple Function</a></h3>
<pre><code>// Simple Function

fn main(){
   //calling a function
   hello();
}

fn hello(){
   println!("Hi");
}
</code></pre>
<h3 id="return-a-value"><a class="header" href="#return-a-value">Return a Value</a></h3>
<pre><code>// Return Value
// Demonstrate the same with the return value (35000.00*5.0*6.4/100.00)

fn main(){
   println!("Hi {}",calc_si());
}

fn calc_si()-&gt;f32 {
   35000.00*5.0*6.4/100.00
}
</code></pre>
<h3 id="call-by-value"><a class="header" href="#call-by-value">Call By Value</a></h3>
<pre><code>// Call by Value

fn main(){
   let no:i32 = 5;
   changeme(no);
   println!("Main Function:{}",no);
}

fn changeme(mut param_no: i32) {
   param_no = param_no * 0;
   println!("Inside the Function :{}",param_no);
}
</code></pre>
<h3 id="call-by-reference"><a class="header" href="#call-by-reference">Call By Reference</a></h3>
<pre><code>// Call by Reference

// Call by Reference

fn main() {
    let mut no: i32 = 5;
    println!("Main fucntion initial value :{} -&gt; {:p}", no,&amp;no);
    changeme(&amp;mut no);
    println!("Main function final value  is:{} -&gt; {:p}", no,&amp;no);
}

fn changeme(param_no: &amp;mut i32) {
    println!("Changeme function initial value :{} -&gt; {:p}", *param_no,&amp;(*param_no));
    *param_no = 0; //de reference
    println!("Changeme function final value :{} -&gt; {:p}", *param_no,&amp;(*param_no));
}

</code></pre>
<p>Call By Reference</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calculator"><a class="header" href="#calculator">Calculator</a></h1>
<pre><code>// Some code

fn add(a: f32, b: f32) -&gt; f32 {
    a + b
}

fn sub(a: f32, b: f32) -&gt; f32 {
    if a &lt; b {
        panic!("first value cannot be less than the second value");
    } else {
        a - b
    }
}

#[allow(dead_code)]
fn mul(a: f32, b: f32) -&gt; f32 {
    a * b
}

#[allow(dead_code)]
fn div(a: f32, b: f32) -&gt; f32 {
    a / b
}

fn main() {
    let a: f32 = 17.0;
    let b: f32 = 33.0;
    let op = "-";
    let mut result: f32 = 0.0;

    if op == "+" {
        result = add(a, b);
    } else if op == "-" {
        result = sub(a, b)
    }

    println!("{result}");
}

#[test]
fn test_add() {
    assert!(add(20.0, 10.0) == 30f32);
}

#[test]
fn test_add1() {
    assert!(add(10.0, 20.0) == 30f32);
}

#[test]
#[should_panic(expected = "cannot be less")]
fn test_sub() {
    assert!(sub(10.0, 20.0) == -10.0f32);
}

#[test]
fn test_sub1() {
    assert!(sub(20.0, 10.0) == 10.0f32);
}

#[test]
#[ignore]
fn test_sub2() {
    assert!(sub(20.0, 10.0) == 10f32);
}

</code></pre>
<h3 id="how-to-test-the-code"><a class="header" href="#how-to-test-the-code">How to Test the code</a></h3>
<pre><code>// Some code

cargo test
</code></pre>
<h3 id="how-to-run-the-code"><a class="header" href="#how-to-run-the-code">How to Run the code</a></h3>
<pre><code>// Some code

cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert-macros"><a class="header" href="#assert-macros">Assert Macros</a></h1>
<pre><code>// Different assert macros

let result = add(2,2);

assert!(result == 4);
assert!(result == 4,"Expected 4; returned result is {}",result);

-----------

let result = add(2,2);

assert_eq!(result,4);

assert_eq!(result,4,"Expected 4; returned result is {}", result);

------------

Similar to the previous one, checks for NOT Equalto.
assert_ne!()

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-cargo-tests"><a class="header" href="#control-cargo-tests">Control Cargo Tests</a></h1>
<h3 id="to-test-all-the-test-cases"><a class="header" href="#to-test-all-the-test-cases">To test all the Test Cases</a></h3>
<pre><code>cargo test
</code></pre>
<h3 id="test-arguments"><a class="header" href="#test-arguments">Test Arguments</a></h3>
<pre><code>cargo test [arguments1] -- [arguments2]

&gt;arguments1 are the arguments for test utility like  help

cargo test --help

&gt;arguments2 are the arguments for the application it's testing.


</code></pre>
<p>By default, cargo displays detailed output for failed test cases. To see the standard output for Success or Failure tests</p>
<pre><code>// Some code

cargo test -- --show-output

Make sure there is no space between --show-output 
</code></pre>
<h3 id="parallel-test-execution"><a class="header" href="#parallel-test-execution">Parallel Test Execution</a></h3>
<p>By default, tests run in parallel by making use of the multi-core architecture.</p>
<p>In some situations (like file handling) there will be a race condition. To avoid that we can make them execute in sequential.</p>
<pre><code>// Runs on single thread

cargo test -- --test-threads=1
</code></pre>
<p>Run test by name</p>
<pre><code>cargo test &lt;testname&gt;

or

cargo test &lt;string&gt; 

cargo runs all tests containing the string in test name.
</code></pre>
<h3 id="ignore-specific-tests"><a class="header" href="#ignore-specific-tests">Ignore specific tests</a></h3>
<pre><code>// Some code

#[test]
#[ignore]

adding this will ignore the test
</code></pre>
<h3 id="run-ignored-tests-only"><a class="header" href="#run-ignored-tests-only">Run ignored tests only</a></h3>
<pre><code>cargo test -- --ignored
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3"><a class="header" href="#chapter-3">Chapter 3</a></h1>
<ul>
<li>
<p><a href="chapter3/memory-management/README.html">memory-management</a></p>
<ul>
<li><a href="chapter3/memory-management/stack-heap.html">stack-heap</a></li>
<li><a href="chapter3/memory-management/borrowing-references.html">borrowing-references</a></li>
<li><a href="chapter3/memory-management/ownership.html">ownership</a></li>
<li><a href="chapter3/memory-management/borrowers.html">borrowers</a></li>
<li><a href="chapter3/memory-management/owner-borrower-stack-heap.html">owner-borrower-stack-heap</a></li>
<li><a href="chapter3/memory-management/dangling-references.html">dangling-references</a></li>
</ul>
</li>
<li>
<p><a href="chapter3/enumerator.html">enumerator</a></p>
</li>
<li>
<p><a href="chapter3/iterator.html">iterator</a></p>
</li>
<li>
<p><a href="chapter3/slices.html">slices</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerator"><a class="header" href="#enumerator">Enumerator</a></h1>
<p>Here are some use cases:</p>
<ol>
<li><strong>Index Tracking</strong>: When you need to know the index of an element while iterating, <code>enumerate()</code> is handy.</li>
<li><strong>Conditional Logic</strong>: Sometimes, the logic inside a loop might depend on the element's index. For example, you might want to skip the first element.</li>
<li><strong>Debugging</strong>: When debugging, knowing the index of an element can help trace or log.</li>
<li><strong>Data Mapping</strong>: When you need to create a new data structure that relies on the index and value from an existing iterable.</li>
</ol>
<p><br />
The enumerator turns an iterator over elements.</p>
<p>Using multiple conditions and variables, a loop condition can also be more complex. For example, the for loop can be tracked using enumerate.</p>
<pre><code>fn main() {
    for (i, j) in (100..200).enumerate() {
        println!("loop has executed {} times. j = {}", i, j);
    }
}
</code></pre>
<pre><code>// _ is a generic placeholder.

fn main()  
{ 
    let my_array: [i32; 7] = [1i32,3,5,7,9,11,13]; 
    let mut value = 0i32; 
    for(_, line) in my_array.iter().enumerate() 
    { 
       value += line; 
    } 
    println!("{}", value); 
} 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<p>Iteration is the process of looping through a set of values.</p>
<p>How its different from Loops?</p>
<p>Loops are Imperative. You must mention how often to loop over and follow Procedural-style programming.</p>
<p>Iterators are Declarative. This means it specifies what to do instead of how to do it and follows Functional Style programming.</p>
<pre><code>// Iterator

fn main() {
    let ages = [27, 35, 40, 10, 19];
    let ages_iterator = ages.iter();

    for age in ages_iterator {
        println!("Age = {:?}", age);
    }
}
</code></pre>
<p><code>Some(T)</code>: Indicates that there is a value, and it's of type <code>T</code></p>
<p>We will discuss more about <strong>Some</strong> in later weeks. It's like you have Some(letter) in your mailbox.</p>
<p>The purpose is to replace the concept of Null and handle Null Safety. It also handles Type Safety.</p>
<pre><code>fn main() {
    let ages = [27, 35, 40, 10, 19];
    let mut ages_iterator = ages.iter();
    
    // println!("{:?}",ages_iterator.next());
    // println!("{:?}",ages_iterator.next());
    // println!("{:?}",ages_iterator.next());
    // println!("{:?}",ages_iterator.next());
    // println!("{:?}",ages_iterator.next());
    // println!("{:?}",ages_iterator.next());
    
    while let Some(x) = ages_iterator.next(){
        println!("{:?}",Some(x));
    }
}
</code></pre>
<pre><code>fn main() {
    let ages = [27, 35, 40, 10, 19];
    let mut ages_iterator = ages.iter();

    // Looping thru Array
    for age in ages {
        println!("Age = {:?}", age);
    }

    println!("{:?}", ages_iterator.next());
    
    // Looping thru an Iterator. See the additional functionality it offers
    
    for age in ages_iterator {
        println!("Age = {:?}", age);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slices"><a class="header" href="#slices">Slices</a></h1>
<p><em>Slices</em> let you reference a contiguous sequence of elements in a collection rather than the whole collection. A slice is a kind of reference, so it does not have ownership.</p>
<p>A <em>string slice</em> is a reference to part of a <code>String</code>, and it looks like this:</p>
<pre><code>// String Slicing

fn main() {
    //define an array of size 4
    let arr:[i32;4] = [1, 2, 3, 4,5,6,7]; 
    
    //define the slice
    let slice_array1 = &amp;arr;
    let slice_array2 = &amp;arr[0..4];
    let slice_array3 = &amp;arr[3..];
    
    // print the slice of an array
    println!("Value of slice_array1: {:?}", slice_array1);
    println!("Value of slice_array2: {:?}", slice_array2);
    println!("Value of slice_array3: {:?}", slice_array3);
}
</code></pre>
<h3 id="example-2"><a class="header" href="#example-2">Example 2</a></h3>
<pre><code>
fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}

fn main() {
    let s = String::from("hello world");
    let word = first_word(&amp;s); // word will get the value 5
    println!("{}",word);
}
</code></pre>
<pre><code>// return value

fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}

fn main() {
    let s = String::from("hello world");
    let word = first_word(&amp;s); // word will get the value 5
    println!("{}",word);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack---heap"><a class="header" href="#stack---heap">Stack - Heap</a></h1>
<figure><img src="chapter3/memory-management/../.gitbook/assets/learn_arduino_Stack_Operation.gif" alt=""><figcaption><p>Src: Adafruit.com</p></figcaption></figure>
<p>We will learn the concept of memory management and how Rust can guarantee memory safety without a Garbage collector.</p>
<p>Like most programming languages, Rust stores data in three different structure parts of your computer memory.</p>
<h3 id="staticdata-memory"><a class="header" href="#staticdata-memory">Static/Data Memory</a></h3>
<p>For data that is fixed in size and static (i.e. always available throughout the life of the program). </p>
<pre><code>println!("Hello");
</code></pre>
<p>This text's bytes are only ever read from one place and therefore can be stored in this region. Compilers make lots of optimizations with this kind of data, and they are generally considered very fast to use since locations are known and fixed.</p>
<p><strong>Program Binary</strong></p>
<p><strong>Static Variables</strong></p>
<p><strong>String Literals</strong></p>
<figure><img src="chapter3/memory-management/../.gitbook/assets/stack_static_global_memory.jpg" alt=""><figcaption><p>Img Src: OpenGenus</p></figcaption></figure>
<h3 id="stack"><a class="header" href="#stack"><strong>Stack</strong></a></h3>
<p><strong>Last In First Out</strong></p>
<p>For data that is declared as variables within a function. The location of this memory never changes for the duration of a function call; because of this compilers can optimize code so stack data is very fast to access.</p>
<p><strong>Function Arguments</strong></p>
<p><strong>Local Variables</strong></p>
<p><strong>Size is known at Compile time</strong></p>
<p>let a:i32 = 100;</p>
<p>Rust knows this will take 32 bits of memory.</p>
<p>So the variable is stored in Stack Memory.</p>
<p>Automatic cleanup, when the function returns.</p>
<p>Example: Courtesy mit.edu</p>
<pre><code>fn foo() {
    let y = 5;
    let z = 100;
}

fn main() {
    let x = 42;

    foo();
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Address</th><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td>0</td><td>x</td><td>42</td></tr>
</tbody></table>
</div>
<p>After calling the function foo()</p>
<div class="table-wrapper"><table><thead><tr><th>Address</th><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td>2</td><td>z</td><td>100</td></tr>
<tr><td>1</td><td>y</td><td>5</td></tr>
<tr><td>0</td><td>x</td><td>42</td></tr>
</tbody></table>
</div>
<p><strong>Note: Memory address is taking into account DATA TYPE SIZE. It's just a representation.</strong></p>
<p>After foo() gets executed, control transfers to main, and the values are deallocated automatically.</p>
<div class="table-wrapper"><table><thead><tr><th>Address</th><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td>0</td><td>x</td><td>42</td></tr>
</tbody></table>
</div>
<h3 id="copy-trait"><a class="header" href="#copy-trait">Copy Trait</a></h3>
<pre><pre class="playground"><code class="language-rust">    fn main() {
    // i32 is a simple type and are normally stored on the stack.
    // copy trait

    let x = 42;
    let y = x; 

    // The value bound to x is Copy, so no error will be raised.
    println!("{:?}", (x, y));

    // The value bound to x is Copy, so no error will be raised.
    println!("{:p},{:p}", &amp;x, &amp;y);
}
</code></pre></pre>
<h3 id="heap"><a class="header" href="#heap"><strong>Heap</strong></a></h3>
<p>For data that is created while the application is running. Data in this region may be added, moved, removed, resized, etc. Because of its dynamic nature, it's generally considered slower to use, but it allows for much more creative usage of memory. When data is added to this region, we call it an allocation. When data is removed from this section, we call it deallocation.</p>
<p>Example: Vector, String</p>
<pre><code>// Some code

fn main(){
    let s1=String::from("hello");
    println!("{}",s1)
}
</code></pre>
<figure><img src="chapter3/memory-management/../.gitbook/assets/string_heap_memory.png" alt=""><figcaption></figcaption></figure>
<pre><code>// Move Trait (Heap)

fn main() {
    let mut name = String::from("Hello World");
    println!("Memory address of name: {},{:p} \n", name,&amp;name);

    //moving

    let name1 = name;
    println!("Memory address of name1: {},{:p} \n", name1,&amp;name1);
    
    //println!("Memory address of name: {},{:p} \n", name,&amp;name);

    // Setting up another Value for the variable name

    name = String::from("Dear World");
    println!("Memory address of name: {},{:p}\n", name,&amp;name);
}
</code></pre>
<p>Example: pdf (stack) - printed book (heap)</p>
<pre><code>// Copy Trait (Stack - because of using String Literal)

fn main() {
    let name = "Hello World";
    println!("Memory address of name: {},{:p} \n", name,&amp;name);

    //Copying

    let name1 = name;
    println!("Memory address of name1: {},{:p} \n", name1,&amp;name1);
    
    println!("Memory address of name: {},{:p} \n", name,&amp;name);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing-references"><a class="header" href="#borrowing-references">Borrowing References</a></h1>
<h3 id="borrowing-immutable-references"><a class="header" href="#borrowing-immutable-references">Borrowing Immutable References</a></h3>
<p>There are few rules when it comes to borrowing. Let's take a quick look at them.</p>
<pre><code>// Cannot change as it's not a mutable reference

fn changeme(param_msg: &amp;String) {
    param_msg.push_str(" Green")
}

fn main() {
    let msg = String::from("Rachel");
    changeme(&amp;msg);
}

</code></pre>
<p><strong>Example</strong>: Borrow a book from the library; you cannot write anything. Just read from it.</p>
<h3 id="borrowing-mutable-references"><a class="header" href="#borrowing-mutable-references">Borrowing Mutable References</a></h3>
<pre><code>// Mutable reference

fn changeme(param_msg: &amp;mut String) {
    param_msg.push_str(" Green")
}

fn main() {
    let mut msg = String::from("Rachel");
    changeme(&amp;mut msg);
    println!("{}", msg);
}
</code></pre>
<p><strong>Example</strong>: Borrow a book from a friend with permission to highlight or underline important items.</p>
<h3 id="immutable-and-mutable-borrow"><a class="header" href="#immutable-and-mutable-borrow">Immutable and Mutable Borrow</a></h3>
<pre><pre class="playground"><code class="language-rust">// Immutable Borrow - Stack

fn main() {
    let x = 5;
    
    // Immutable borrow
    let y = &amp;x;
    // *y += 1;
    println!("Value of y: {}", y);
   

}
</code></pre></pre>
<p><strong>Immutable Borrow</strong>: Allows read-only access to a value. Multiple immutable borrows can coexist, but they cannot coexist with a mutable borrow.</p>
<pre><pre class="playground"><code class="language-rust">// Mutable Borrow - Stack

fn main() {
    let mut x = 5;
    println!("Value of x: {}", x);
    
    // Mutable borrow
    let z = &amp;mut x;
    *z += 1;
    println!("Value of x: {}", x);
}</code></pre></pre>
<p><strong>Mutable Borrow</strong>: Grants read-write access to a value. Only one mutable borrow is allowed at a time, and no immutable borrows can coexist.</p>
<hr />
<p><strong>Immutable and Mutable Borrow</strong></p>
<p><strong>Rule</strong>: Immutable borrow should always be <strong>used</strong> in the code after the mutable borrow because whatever modifications are done by mutable borrow should not affect immutable borrow. </p>
<p>That’s why they always use immutable borrows after mutable borrows.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    
    // Mutable borrow
    let z = &amp;mut x;
    *z += 1;
    
    println!("Value of z: {}-&gt;{:p}", z, &amp;z);
    
    println!("Value of x: {}-&gt;{:p}", x, &amp;x);
    
    // immutable borrows
    let y1 = &amp;x;
    println!("Value of y1: {}-&gt;{:p}", y1, &amp;y1);
    
    // Flip the immutable and mutable and print the Immutable value after Mutable
  
}</code></pre></pre>
<p>Use this website to sort the Memory locations to understand how values are stored in Stack. You can sort them by ASC or DESC order.</p>
<p><a href="https://www.rajeshvu.com/storage/emc/utils/general/sorthexnumbers">https://www.rajeshvu.com/storage/emc/utils/general/sorthexnumbers</a></p>
<p><strong>Borrow Checker</strong></p>
<p>Exactly. When <code>b</code> has a mutable borrow of <code>a</code>, <code>a</code> temporarily loses its write privilege. You can't modify <code>a</code> or even read from it while <code>b</code> has an active mutable borrow. Rust's <strong>borrow checker</strong> enforces this to ensure memory safety.</p>
<p>If you try to access <strong><code>a</code></strong> while <strong><code>b</code></strong> has an active mutable borrow, Rust's borrow checker will complain. This ensures you don't have multiple mutable references to the same data, which could lead to <strong>data races</strong> and undefined behavior. The borrow checker enforces these rules at compile time for memory safety.</p>
<pre><pre class="playground"><code class="language-rust">// Borrow Checker - String - Heap

fn main() {
    let mut a = String::from("Rachel");
    
    let b = &amp;mut a;
    
    println!("variable 'b' initial value is {} stored at this {:p}", b,b.as_ptr());
    
    b.push_str(" Green");
    
    //println!("variable 'a' {}{:p}", a,a.as_ptr());
    
    println!("variable 'b' {} {:p}", b,b.as_ptr());
    
    // println!("variable 'a' {}{:p}", a,a.as_ptr());
    
    b.push_str(" !");
    
    println!("variable 'b' after update {},{:p}", b,b.as_ptr());
    
    println!("variable 'a' after update {} {:p}", a,a.as_ptr());
}</code></pre></pre>
<p><strong>Example</strong>: The book owner can use the book only after the borrowed person has completed the work.</p>
<h3 id="multiple-mutable-borrowers"><a class="header" href="#multiple-mutable-borrowers">Multiple Mutable Borrowers</a></h3>
<pre><pre class="playground"><code class="language-rust">// Not allowed to have multiple Mutable Borrowers at the same time/scope

fn main() {
    let mut a = String::from("Rachel");
    
    let b = &amp;mut a;
    let c = &amp;mut a;
    
    println!("{}", b);
    println!("{}", c);
   
}</code></pre></pre>
<p><strong>Example</strong>: Two friends borrow the same book to highlight the important items.</p>
<pre><pre class="playground"><code class="language-rust">// Multiple Mutable Borrowers (different scope)

fn main() {
    let mut a = String::from("Rachel");
   
    let b = &amp;mut a;
    println!("{}", b);

    let c = &amp;mut a;
    println!("{}", c);
}</code></pre></pre>
<p><strong>Example</strong>: 2 friends borrow the book one after another for writing.</p>
<p>For clarity's sake, the above code can be written this way, too.</p>
<pre><pre class="playground"><code class="language-rust">// Multiple Mutable Borrowers (different scope)

fn main() {
    let mut a = String::from("Rachel");

    {    
       let b = &amp;mut a;
        println!("{}", b);
    }

    let c = &amp;mut a;
    println!("{}", c);
}</code></pre></pre>
<h3 id="immutable-and-mutable"><a class="header" href="#immutable-and-mutable">Immutable and Mutable</a></h3>
<p>Mutable  first, followed by Immutable</p>
<pre><pre class="playground"><code class="language-rust">// Immutable and Mutable

fn main() {
    let mut a = String::from("Rachel");
    
    let c = &amp;mut a;
    c.push_str("!");
    println!("c = {}", c);
    
    let b = &amp;a;
    println!("b = {}", b);
</code></pre></pre>
<p><strong>Rules</strong>:</p>
<ol>
<li>Multiple Immutable references are allowed in the same scope.</li>
<li>Immutable and Mutable references are not allowed in the same scope.</li>
<li>Immutable and Mutable references are allowed in different scopes.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<h3 id="ownership-1"><a class="header" href="#ownership-1">Ownership</a></h3>
<p>It's a unique &amp; critical aspect of Rust.</p>
<p><strong>In C/C++ there is no concept called a Garbage Collector. (which frees up the unused memory).</strong></p>
<ul>
<li>But they are very fast and performant.</li>
<li>Developers need to work to free up memory. (remember free() function?)</li>
</ul>
<p><strong>In other languages such as Python, Java, and Go we have Garbage Collector</strong></p>
<ul>
<li>Relatively slower</li>
<li>Developers can focus only on business logic.</li>
</ul>
<h3 id="rust-ownership-system"><a class="header" href="#rust-ownership-system">Rust Ownership System</a></h3>
<ul>
<li>Best of both worlds.</li>
<li>The Compiler replaces most of GC's responsibilities.</li>
<li>Determines at compile time when memory is allocated and deallocated.</li>
<li>Requires developers to code in specific ways. (All the checks and balances)</li>
</ul>
<h3 id="rules-of-ownership"><a class="header" href="#rules-of-ownership">Rules of Ownership</a></h3>
<ul>
<li>Each value in Rust has a variable that is called its Owner.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<p><em>{:p} - Pointer Trait, used to print the memory location of variables.</em></p>
<pre><code>// Demonstrate Shadowing

fn main() {
    let x = String::from("Rachel");
    println!("Memory address of x: {:p}", &amp;x);
    
    // new x is created in another memory location
    let x = 5;
    println!("Memory address of x: {:p}", &amp;x);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowers"><a class="header" href="#borrowers">Borrowers</a></h1>
<p>Access data without taking ownership of it by creating references using the borrow operator (&amp;)</p>
<p>We are familiar with this operator in the call by reference.</p>
<pre><code>// Print Name - The second print fails because the name transferred its ownership to p_name

fn printname(p_name:String){
    println!("{name}")
}

fn main() {
    let name:String = String::from("Rachel");
    printname(name);
    printname(name);
}
</code></pre>
<h3 id="how-to-fix-it"><a class="header" href="#how-to-fix-it">How to fix it?</a></h3>
<h3 id="borrowing-concept"><a class="header" href="#borrowing-concept">Borrowing Concept</a></h3>
<pre><code>// Instead of passing the actual value, passing the Reference / Borrow operator

fn printname(p_name:&amp;String){
    println!("{p_name}")
}

// by default len() returns usize.

fn get_length(p_name: &amp;String) -&gt; i8 {
    let name_length:i8 = p_name.len() as i8;
    name_length
}

fn main() {
    let name:String = String::from("Rachel");
    printname(&amp;name);
    printname(&amp;name);
    let name_length = get_length(&amp;name);
    println!("Length is {name_length}");
}
</code></pre>
<h3 id="using-stringclone"><a class="header" href="#using-stringclone">Using String.clone()</a></h3>
<pre><code>// String.clone()

fn printname(name:String){
    println!("{},{:p}",name,&amp;name)
}

fn main() {
    let name:String = String::from("Rachel");
    printname(name.clone());
    printname(name.clone());
    printname(name);
}
</code></pre>
<h3 id=""><a class="header" href="#"></a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="owner-borrower-stack-heap"><a class="header" href="#owner-borrower-stack-heap">Owner Borrower Stack Heap</a></h1>
<pre><code>// Owner - Borrower - Stack - Heap - Slices

fn main() {
    //Create a String Object o with the value Rachel Green

    let o = String::from("Rachel Green");
    println!("Value of the variable 'o' is {o}");

    // .len() - returns the actual length
    println!("\nString Length: {}", o.len());
    // .capacity() - memory reserved for String Object
    println!("String Capacity: {}", o.capacity());

    // as_ptr(): Returns a raw pointer to the underlying data in this cell.
    println!("Heap location of {o} starts at {:p}", o.as_ptr());

    ////////////

    //Slicing variable o and get the second portion of the variable, that is, Green
    let s = &amp;o[7..12];

    println!("\nValue of the variable 's' is {s}");
    println!("Heap location of {s} starts at {:p}", s.as_ptr());

    // Get the stack location of variables o and s
    println!("\nStack location of owner 'o' {:p}", &amp;o);
    println!("Stack location of owner 's' {:p}", &amp;s);

    //////////

    // o is the owner, and b is the borrower.
    let b = &amp;o;

    println!("\nBorrower 'b' is {}", b);
    println!("Borrower 'b' points to Owner 'o' {:p}", b);
    println!("Stack location of borrower 'b' {:p}", &amp;b);
    println!("Value borrower 'b' pointing to 'o' location {:p}",b.as_ptr());
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dangling-references"><a class="header" href="#dangling-references">Dangling References</a></h1>
<p>A dangling reference occurs when you have a reference that points to an invalid memory location, usually because the data it refers to has been deallocated or moved. In languages like C and C++, this can lead to undefined behavior.</p>
<p><strong>Rust's ownership model is designed to eliminate this issue</strong>. The borrow checker ensures that references cannot outlive the data they point to, making dangling references impossible in safe Rust code.</p>
<pre><pre class="playground"><code class="language-rust">// Dangling Reference

fn main() {
    let r;
    {
        let x = 42;
        r = &amp;x;
    }
    println!("r: {}", r);  // This won't compile
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Dangling Reference

fn get_name() -&gt; &amp;String{
    let name = String::from("Rachel");
    &amp;name
}

fn main() {
    let name:String = get_name();
    println!("new name is {name}");
}</code></pre></pre>
<p>The above code results in an error.</p>
<pre><code>this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
</code></pre>
<p>The function get_name returns a reference variable <strong>&amp;name</strong>;</p>
<p>After the function is done, the variable goes out of scope, leading to a NULL Pointer reference.</p>
<p>This is allowed in other languages like C++, leading to memory issues.</p>
<p><strong>How to solve it?</strong></p>
<p>Remove the &amp; from the <strong>return value and get_name()</strong> definition and return the variable. </p>
<pre><pre class="playground"><code class="language-rust">fn get_name() -&gt; String{
    let name = String::from("Rachel");
    name
}

fn main() {
    let name:String = get_name();
    println!("new name is {name}");
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4"><a class="header" href="#chapter-4">Chapter 4</a></h1>
<ul>
<li>
<p><a href="chapter4/complex-datatypes/README.html">complex-datatypes</a></p>
<ul>
<li><a href="chapter4/complex-datatypes/vector-datatype.html">vector-datatype</a></li>
<li><a href="chapter4/complex-datatypes/structs.html">structs</a></li>
<li><a href="chapter4/complex-datatypes/enums.html">enums</a></li>
<li><a href="chapter4/complex-datatypes/hash-map.html">hash-map</a></li>
<li><a href="chapter4/complex-datatypes/type-alias.html">type-alias</a></li>
</ul>
</li>
<li>
<p><a href="chapter4/input-from-user.html">input-from-user</a></p>
</li>
<li>
<p><a href="chapter4/vector-struct-input.html">vector-struct-input</a></p>
</li>
<li>
<p><a href="chapter4/command-line-args.html">command-line-args</a></p>
</li>
<li>
<p><a href="chapter4/modules/README.html">modules</a></p>
<ul>
<li><a href="chapter4/modules/module-sub-folders.html">module-sub-folders</a></li>
<li><a href="chapter4/modules/module-multiple-files.html">module-multiple-files</a></li>
<li><a href="chapter4/modules/user-defined-module.html">user-defined-module</a></li>
<li><a href="chapter4/modules/creating-a-library.html">creating-a-library</a></li>
<li><a href="chapter4/modules/standard-modules.html">standard-modules</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-args"><a class="header" href="#command-line-args">Command Line Args</a></h1>
<p>Command Line Arguments</p>
<p>CLI Arguments are passed to the program when it is invoked.</p>
<p><strong>Example</strong></p>
<p><code>rustc --version</code></p>
<p><em>Commonly used for File Paths &amp; Configuration Settings.</em></p>
<p>To use Command Line Arguments, you need to include a standard libraries environment module.</p>
<p><strong>std::env::args</strong></p>
<p>Returns an iterator over arguments passed to the program.</p>
<p>The first argument is traditionally the executable path.</p>
<pre><code>// command line arguments

use std::env;

fn main(){
for (index,argument) in  env::args().enumerate(){
   
    println!("{},{}", index, argument)
}
}
</code></pre>
<p>Pick a specific argument.</p>
<pre><code>// option 1

let arg2 = eng::args().nth(2);
prinln!("{}", arg2);

// another option
let name = env::args().skip(1).next();

// dbg macro
dbg!(env::args());
</code></pre>
<p><strong>Some</strong></p>
<pre><code>use std::env;

fn main() {
    println!("{:?}",env::args());
    
    let name = env::args().skip(1).next();
    
    match name{
        Some(n) =&gt; println!("Hi {n}"),
        None =&gt; panic!("Missing parameter")
    }
   
}
</code></pre>
<p>Checking for the number of arguments. </p>
<p>Example for copying you need  src and destination </p>
<pre><code>
if env::args().len() &lt;= 2{
    println!("need atleast 2 args");
    return;  //exists the program
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-from-user"><a class="header" href="#input-from-user">Input from user</a></h1>
<pre><code>// Input String

use std::io;

fn main(){
    println!("Please enter your name: ");

    let mut name = String::new();
    io::stdin().read_line(&amp;mut name).expect("Failed");

    println!("Welcome {}",name);
}

</code></pre>
<p>Expect (): Is used when the program panics.</p>
<pre><code>// Accept two numbers

use std::io;

fn main(){
    println!("Enter First Number: ");

    let mut s1 = String::new();
    io::stdin().read_line(&amp;mut s1).expect("Not a valid input");
    let n1:u32 = s1.trim().parse().expect("Not a valid Number");

    
    println!("Enter Second Number: ");
    let mut s2 = String::new();
    io::stdin().read_line(&amp;mut s2).expect("Not a valid input");
    let n2:u32 = s2.trim().parse().expect("Not a valid Number");


    let result = n1 + n2;

    println!("Result : {result}");
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector---struct---input"><a class="header" href="#vector---struct---input">Vector - Struct - Input</a></h1>
<pre><pre class="playground"><code class="language-rust">use std::io;

#[derive(Debug)]
struct User {
    id: String,
    first_name: String,
    last_name: String,
    status: String,
}

fn main() {
    let mut users: Vec&lt;User&gt; = Vec::new();

    loop {
        println!("Enter 'id', 'first name', 'last name', 'status' separated by SPAC:");
        let mut input = String::new();
        io::stdin().read_line(&amp;mut input).unwrap();
        let parts: Vec&lt;&amp;str&gt; = input.trim().split_whitespace().collect();

        if parts.len() != 4 {
            println!("Invalid input. Please enter 4 values.");
            continue;
        }

        let new_user = User {
            id: parts[0].to_string(),
            first_name: parts[1].to_string(),
            last_name: parts[2].to_string(),
            status: parts[3].to_string(),
        };

        users.push(new_user);

        println!("Do you want to add another user? (Yes/No/Y/N): ");
        let mut continue_input = String::new();
        io::stdin().read_line(&amp;mut continue_input).unwrap();

        if continue_input.trim().eq_ignore_ascii_case("n") || continue_input.trim().eq_ignore_ascii_case("no")  {
            break;
        }
    }

    println!("\nAll users:");
    for user in users {
        println!("{},{},{},{}", user.id, user.first_name, user.last_name, user.status);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="complex-datatypes"><a class="header" href="#complex-datatypes">Complex Datatypes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector-datatype"><a class="header" href="#vector-datatype">Vector Datatype</a></h1>
<p><strong>Dynamic Arrays</strong> </p>
<p>Unlike Arrays no need to initialize the size of the array.</p>
<pre><code>// Vector

fn main(){
    let mut my_vec = Vec::new();
    my_vec.push("Rachel");
    my_vec.push("Monica");
    my_vec.push("Phoebe");
    
    println!("{:?}",my_vec);
       
}
</code></pre>
<p><strong>Vector with Datatype</strong></p>
<pre><code>// This vector is initialized with i32 datatype.
// This code will result in error.

fn main(){
    let mut my_vec: Vec&lt;i32&gt; = Vec::new();
    
    my_vec.push("Rachel");
    my_vec.push("Monica");
    my_vec.push("Phoebe");
    
    println!("{:?}",my_vec);
    
}
</code></pre>
<p><strong>What about this?</strong></p>
<pre><code>// &amp;str

fn main(){
    let mut my_vec: Vec&lt;&amp;str&gt; = Vec::new();
    my_vec.push("Rachel");
    my_vec.push("Monica");
    my_vec.push("Phoebe");
    
    println!("{:?}",my_vec);
    
}
</code></pre>
<pre><code>// String

fn main(){
    let mut my_vec: Vec&lt;String&gt; = Vec::new();
    my_vec.push("Rachel".to_string());
    my_vec.push("Monica".to_string());
    my_vec.push("Phoebe".to_string());
   
    println!("{:?}",my_vec);  
}
</code></pre>
<h3 id="vec-macro-for-initializing"><a class="header" href="#vec-macro-for-initializing">Vec Macro for initializing</a></h3>
<pre><code>// Vec macro

fn main(){
    //Using vec macro
    let my_vec = vec![2,4,6,8,10,12,14,16];
    
    let one = &amp;my_vec[2..6];
    let two = &amp;my_vec[2..];
    let three = &amp;my_vec[..6];
    let four = &amp;my_vec[..];
    
    println!("{:?}",one);
    println!("{:?}",two);
    println!("{:?}",three);
    println!("{:?}",four);
    
    
}
</code></pre>
<h3 id="capacity-vs-len"><a class="header" href="#capacity-vs-len">Capacity() vs Len()</a></h3>
<pre><code>// capacity() number of elements the vector can hold (without reallocating memory)
// len() number of elements

fn main(){
    let mut my_vec: Vec&lt;String&gt; = Vec::new();
    my_vec.push("Rachel".to_string());
    my_vec.push("Monica".to_string());
    my_vec.push("Phoebe".to_string());

    println!("{:?}",my_vec);
    println!("{}",my_vec.capacity());
    println!("{}",my_vec.len());
    
    // now Rust is allocating space for 103 elements
    my_vec.reserve(100);
    
    println!("{}",my_vec.capacity());
    println!("{}",my_vec.len());
    
}
</code></pre>
<h3 id="convert-array-to-vector"><a class="header" href="#convert-array-to-vector">Convert Array to Vector</a></h3>
<pre><code>fn main(){
    let arr1 = [1,2,3,4];
    let my_vec:Vec&lt;i8&gt; = arr1.into();
    let my_vec1:Vec&lt;_&gt; = arr1.into();
    
    println!("{:?},{:?},{:?}",arr1,my_vec,my_vec1);
    
    print_type_of(&amp;arr1);
    print_type_of(&amp;my_vec);
    print_type_of(&amp;my_vec1);
}


fn print_type_of&lt;T&gt;(_: &amp;T) {
    println!("{}", std::any::type_name::&lt;T&gt;())
}
</code></pre>
<h3 id="sort-the-vector"><a class="header" href="#sort-the-vector">Sort the Vector</a></h3>
<pre><code>fn main() {
    let mut vec = vec![14, 33, 12, 56, 3223, 2211, 9122, 3, 299, 67];
    vec.sort();
    println!("Sorted: {:?}", vec)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Popular custom datatype for grouping related values. Like a Tuple, Structs help to group related values of mixed data types.</p>
<p>Unlike a Tuple, you will assign a name to each value to indicate what it means. In the tuple, you will be using .0 .1 notation, but with struct, you can use the actual name.</p>
<h3 id="classic-struct"><a class="header" href="#classic-struct">Classic Struct</a></h3>
<pre><code>- Most commonly used.
- Each field has a name and a type.
</code></pre>
<pre><code>struct Students {
	id:i32,
	name:String,
	course:String
}

fn main(){
    let s:Students = Students{
        id:10,
        name:String::from("Rachel"),
        course:String::from("DB")
    };

    println!("{},{},{}",s.id,s.name,s.course);

}
</code></pre>
<p>Similar to Type alias, the name of the struct begins with an uppercase letter followed by lowercase characters.</p>
<p>Structs are usually declared outside the main function. If the scope is local, it can be declared inside the main.</p>
<h4 id="struct---stack-or-heap"><a class="header" href="#struct---stack-or-heap">Struct - Stack or Heap?</a></h4>
<pre><code>// Struct Stack or Heap

struct Students {
    id: i32
}

fn main() {
    let s: Students = Students {
        id: 10
    };

    let s4 = s; //Is this COPY or Move ?
    
    println!("{}",s.id)
    
}
</code></pre>
<pre><code>// lets clone it so we can make a copy of the Struct

let s4 = s.clone();
</code></pre>
<p>What do we see now?</p>
<pre><code>method `clone` not found for this struct
</code></pre>
<p>Let's set the Clone trait for the struct Students</p>
<pre><code>// Adding Clone trait to the struct Students
#[derive(Clone)]
struct Students{id:i32}
</code></pre>
<p>Instead of printing s.id can you try printing the entire Struct?</p>
<pre><code>// Using debug trait print the value of S

println!("{:?}",s);
</code></pre>
<p>Now, what do you see?</p>
<pre><code>// Adding Clone and Debug trait to the struct Students

#[derive(Clone,Debug)]
struct Students{id:i32}
</code></pre>
<h4 id="struct-inside-vector"><a class="header" href="#struct-inside-vector">Struct inside Vector</a></h4>
<pre><code>
#[derive(Debug, Clone)]
struct Students {
    id: i32,
    name: String,
    course: String,
}

fn main() {
    let s: Students = Students {
        id: 10,
        name: String::from("Rachel"),
        course: String::from("DB"),
    };

    let s1: Students = Students {
        id: 11,
        name: String::from("Monica"),
        course: String::from("DB"),
    };

    let s2: Students = Students {
        id: 12,
        name: String::from("Phoebe"),
        course: String::from("DB"),
    };

    let mut s_vec: Vec&lt;Students&gt; = Vec::new();

    s_vec.push(s);
    s_vec.push(s1);
    s_vec.push(s2);

    for v in s_vec.iter() {
         println!("{},{},{}", v.id, v.name, v.course);
    }
}

</code></pre>
<h3 id="struct-implementation"><a class="header" href="#struct-implementation">Struct implementation</a></h3>
<p>The implementation block has the keyword "impl" followed by the same name as Struct. It contains methods and functions. A struct can have more than one method or function.</p>
<p>Methods: methods are similar to functions with "fn" keyword. They can have parameters and return values. The only difference is, they are defined within the context of a struct and their first parameter is always self.</p>
<p> Let's see an example</p>
<pre><code>// 

#[derive(Debug, Clone)]
struct Students {
    id: i32,
    name: String,
    course: String,
}

impl Students {
    
    // either use self or self: &amp;Self it all means the same
    //fn get_student_details(self){
    
    fn get_student_details(self: &amp;Self){
        println!("{}", self.id);
        println!("{}", self.name);
        println!("{}", self.course);
    }

}

fn main() {
    let s: Students = Students {
        id: 10,
        name: String::from("Rachel"),
        course: String::from("DB"),
    };
    
    let s1: Students = Students {
        id: 11,
        name: String::from("Monica"),
        course: String::from("DB"),
    };
    
    s.get_student_details();
    s1.get_student_details();
}    
</code></pre>
<h4 id="using-associated-function"><a class="header" href="#using-associated-function">Using Associated Function</a></h4>
<p>Functions inside the impl block that do not take "self" as a parameter. </p>
<pre><code>// Some code

#[derive(Debug, Clone)]
struct Students {
    id: i32,
    name: String,
    course: String,
}

impl Students {
    fn get_student_details(self){
        println!("{}", self.id);
        println!("{}", self.name);
        println!("{}", self.course);
    }
    
    fn create_student(pid:i32,pname:String,pcourse:String) -&gt; Students{
        Students{id:pid,name:pname,course:pcourse}
    }
}

fn main() {

    // let s: Students = Students {
    //     id: 10,
    //     name: String::from("Rachel"),
    //     course: String::from("DB"),
    // };
    
    // let s1: Students = Students {
    //     id: 11,
    //     name: String::from("Monica"),
    //     course: String::from("DB"),
    // };
    
    // s.get_student_details();
    // s1.get_student_details();
    
    // Creating Student using Associated Function and printing it via Method
    
    let s2 = Students::create_student(12,"Ross".to_string(),"C++".to_string());
    s2.get_student_details();
}    
</code></pre>
<h4 id="mutable-implementation"><a class="header" href="#mutable-implementation">Mutable Implementation</a></h4>
<pre><code>// Using Mutable &amp; Borrow operator

#[derive(Debug, Clone)]
struct Students {
    id: i32,
    name: String,
    course: String,
}

impl Students {
    fn get_student_details(&amp;self){
        println!("-------------------");
        println!("{}", self.id);
        println!("{}", self.name);
        println!("{}", self.course);
        println!("-------------------");
    }
    
    fn create_student(pid:i32,pname:String,pcourse:String) -&gt; Students{
        Students{id:pid,name:pname,course:pcourse}
    }
    
    fn change_student_details(&amp;mut self, id:i32, new_name:String, new_course:String){
        self.name=new_name;
        self.course=new_course;
    }
}

fn main() {

    let s = Students {
        id: 10,
        name: String::from("Rachel"),
        course: String::from("DB"),
    };
    
    let s1 = Students {
        id: 11,
        name: String::from("Monica"),
        course: String::from("DB"),
    };
    
    s.get_student_details();
    s1.get_student_details();
    
    // Creating Student using Associated Function and printing it via Method
    
    let mut s2 = Students::create_student(12,"Ross".to_string(),"C++".to_string());
    s2.get_student_details();
    
    s2.change_student_details(12,"Ross Geller".to_string(),"CPP".to_string());
    s2.get_student_details();
}    
</code></pre>
<h3 id="tuple-struct"><a class="header" href="#tuple-struct">Tuple Struct</a></h3>
<p>Tuple Structs - Similar to Classic but fields have no names.</p>
<pre><code>// Tuple Struct

struct Coordinates(u32, u32);

fn main() {
    let xy = Coordinates(10, 20);
    //it behaves like Tuples
    println!("Value of the Tuple Struct xy {},{}", xy.0, xy.1);
    
    //Destructuring Tuple Struct

    let Coordinates(a,b) = xy;
    println!("Values of variables a &amp; b {},{}", a, b);
}


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p><strong>Enumerators</strong></p>
<p>Define a data type with multiple possible variants</p>
<p>It Enumerates a finite number of options or types.</p>
<ul>
<li>Create custom enum types.</li>
<li>How enums are commonly used.</li>
<li>There are few standard enums you will use in Rust.</li>
</ul>
<pre><code>#[derive(Debug)]
enum TrafficLight{
    Red,
    Yellow,
    Green
}

fn main(){
    let my_light = TrafficLight::Red;

    println!("{:?}", my_light);
}
</code></pre>
<p>In addition to simply representing one of several types, we can have additional data based on the value.</p>
<p>Let's add Unnamed parameters in parenthesis.</p>
<pre><code>// Enum with additional data

#[derive(Debug)]
enum TrafficLight{
    Red (bool),
    Yellow (bool),
    Green (bool)
}

fn main(){
    let my_light = TrafficLight::Red(true);

    println!("{:?}", my_light);
}
</code></pre>
<pre><code>// Separate the value and enum result

#[derive(Debug)]
enum TrafficLight{
    Red (bool),
    Yellow (bool),
    Green (bool)
}

fn main(){
    let my_light = TrafficLight::Red(false);

    println!("{:?}", my_light);
    
    match my_light {
        TrafficLight::Red(is_active) =&gt; println!("Red: {}", is_active),
        TrafficLight::Yellow(is_active) =&gt; println!("Yellow: {}", is_active),
        TrafficLight::Green(is_active) =&gt; println!("Green: {}", is_active),
    }
}
</code></pre>
<h3 id="enums-inside-enums"><a class="header" href="#enums-inside-enums">Enums inside Enums</a></h3>
<pre><code>#[derive(Debug)]
enum TrafficLight {
    Red(bool),
    Yellow(bool),
    Green(bool),
}

#[derive(Debug)]
enum Vehicle {
    Stop,
    Drive(f64),
    CheckLight(TrafficLight),
}

fn main() {
    let my_light = TrafficLight::Red(true);
    let instruction = Vehicle::CheckLight(my_light);

    match instruction {
        Vehicle::Stop =&gt; println!("Stop"),
        Vehicle::Drive(speed) =&gt; println!("Drive at speed: {}", speed),
        Vehicle::CheckLight(light) =&gt; match light {
            TrafficLight::Red(is_active) =&gt; println!("Red light: {}", is_active),
            TrafficLight::Yellow(is_active) =&gt; println!("Yellow light: {}", is_active),
            TrafficLight::Green(is_active) =&gt; println!("Green light: {}", is_active),
        },
    }
}

</code></pre>
<p>In Database world, commonly usages are</p>
<pre><code>enum FileFormat {
    CSV,
    Parquet,
    Avro,
    JSON,
    XML,
}

enum LogLevel {
    Debug,
    Info,
    Warn,
    Error,
    Critical,
}


enum DataTier {
    Hot,
    Warm,
    Cold,
    Archived,
}


</code></pre>
<h3 id="enum-implements"><a class="header" href="#enum-implements">Enum Implements</a></h3>
<p>Similar to Struct, you can implement an interface in Enum.</p>
<p>The Implement interface can be helpful when we need to implement some business logic tightly coupled with a discriminatory property of a given enum.</p>
<pre><code>// Modified from Source: Barron Stone Git Repository

#[derive(Debug)]
enum Shape {
    Circle(f64), // radius
    Rectangle(f64, f64), // width, height
    Triangle(f64, f64, f64) // sides a, b, c
}

impl Shape {
    fn get_perimeter(&amp;self) -&gt; f64 {
        match *self {
            Shape::Circle(r) =&gt; r * 2.0 * std::f64::consts::PI,
            Shape::Rectangle(w, h) =&gt; (2.0 * w) + (2.0 * h),
            Shape::Triangle(a, b, c) =&gt; a + b + c
        }
    }
}

fn main() {
    let my_shape = Shape::Circle(1.2);
    println!("my_shape is {:?}", my_shape);

    let perimeter = my_shape.get_perimeter();
    println!("perimeter is {}", perimeter);
    
    let my_shape1 = Shape::Triangle(3.0,4.0,5.0);
    println!("my_shape is {:?}", my_shape1);

    let perimeter1 = my_shape1.get_perimeter();
    println!("perimeter is {}", perimeter1);
    
    
    let my_shape2 = Shape::Rectangle(4.0,5.0);
    println!("my_shape is {:?}", my_shape2);

    let perimeter2 = my_shape2.get_perimeter();
    println!("perimeter is {}", perimeter2);
    
}
</code></pre>
<h2 id="commonly-used-standard-enums"><a class="header" href="#commonly-used-standard-enums">Commonly used standard Enums</a></h2>
<h3 id="option"><a class="header" href="#option">Option</a></h3>
<p>Many languages use NULL to indicate no value.</p>
<p>Errors often occur when using a NULL.</p>
<p>Rust does not have a traditional null value.</p>
<pre><code>// Sample Option Enum

fn main() {
    let x = Some(5);  //Option &lt;i32&gt;
    let y = Some(4.0); // Option &lt;f64&gt;
    let z = Some("Hello"); //Option &lt;&amp;str&gt;
    let a = None; //N should be upper case
    let a_vec: Option&lt;Vec&lt;i32&gt;&gt; = Some(vec![0, 1, 2, 3]);
}
</code></pre>
<pre><code>// Simple Division

fn try_division(dividend: i32, divisor: i32) -&gt; i32 {
    dividend / divisor
}

fn main() {
    println!("{}",try_division(4, 2));
    //println!("{}",try_division(4, 0));
}
</code></pre>
<p>Sometimes it's desirable to catch the failure of some parts of a program instead of calling <code>panic!</code>; this can be accomplished using the <code>Option</code> enum.</p>
<pre><code>// Common Enum

enum Option &lt;T&gt;{
    Some(T),
    None
}
</code></pre>
<p>This achieves the same concept as a traditional null value, but implementing it in terms of an enum data type compiler can check to make sure you are handling it correctly.</p>
<p>It's commonly used and included in the prelude. That means additional use statements are needed.</p>
<pre><code>// Error Handling

// An integer division that doesn't `panic!`
fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor == 0 {
        // Failure is represented as the `None` variant
        None
    } else {
        // Result is wrapped in a `Some` variant
        Some(dividend / divisor)
    }
}

fn try_division(dividend: i32, divisor: i32) {
    // `Option` values can be pattern matched, just like other enums
    match checked_division(dividend, divisor) {
        None =&gt; println!("{} / {} failed!", dividend, divisor),
        Some(quotient) =&gt; {
            println!("{} / {} = {}", dividend, divisor, quotient)
        },
    }
}

fn main() {
    //try_division(4, 2);
    try_division(4, 0);
    
}
</code></pre>
<h3 id="result"><a class="header" href="#result">Result</a></h3>
<pre><code>// Another Prelude

enum Result&lt;T, E&gt;{
  Ok(T),
  Err(E)
}
</code></pre>
<h4 id="okt"><a class="header" href="#okt"><code>Ok(T)</code> <a href="chapter4/complex-datatypes/enums.html#variant.ok" id="variant.ok"></a></a></h4>
<p>It contains the success value.</p>
<h4 id="erre"><a class="header" href="#erre"><code>Err(E)</code></a></h4>
<p>Contains the error value</p>
<pre><code>// Simple Simple Interest Function

fn si(p:f32,n:f32,r:f32) -&gt; f32 {
	(p * n * r )/100 as f32
}


fn main(){
	let p:f32 = 10000.00;
	let n:f32 = 3.00;
	let r:f32 = 1.4;

	let si = si(p,n,r);
	println!("Simple Interest = {si}");
}
</code></pre>
<p><strong>How to handle if the parameter is Zero?</strong></p>
<pre><code>// SI with conditions

fn si(p:f32,n:f32,r:f32) -&gt; f32 {
    if p &lt;= 0. {
        println!("p cannot be zero");
    }
    
    if n &lt;= 0.{
        println!("n cannot be zero");
    }
    
    if r &lt;= 0. {
        println!("r cannot be zero");
    }
    
	(p * n * r )/100 as f32
}


fn main(){
	let p:f32 = 10000.00;
	let n:f32 = 3.00;
	let r:f32 = 0.0;

	let si = si(p,n,r);
	println!("Simple Interest = {si}");
}
</code></pre>
<p>Do you notice any issues with this?</p>
<p>Yes, the message is displayed, but still, the calculation takes place, and the Error message is only for informational purposes.</p>
<p>How does Result enum help in this case?</p>
<pre><code>// using Result

fn si(p: f32, n: f32, r: f32) -&gt; Result&lt;f32, String&gt; {
    if p &lt;= 0. {
        return Err("Principal cannot be less or equal to zero".to_string());
    }

    if n &lt;= 0. {
        return Err("Number of years cannot be less or equal to zero".to_string());
    }

    if r &lt;= 0. {
        return Err("Rate cannot be less or equal to zero".to_string());
    }

    Ok((p * n * r) / 100.0)
}

fn main() {
    let p: f32 = 10000.0;
    let n: f32 = 3.0;
    let r: f32 = 1.4;

    match si(p, n, r) {
        Ok(result) =&gt; println!("si = {result}"),
        Err(e) =&gt; println!("error occured {:?}", e),
    }
}
</code></pre>
<p><strong>Difference when using Result and Option Example</strong></p>
<pre><code>// using Result

fn si_using_result(p: f32, n: f32, r: f32) -&gt; Result&lt;f32, String&gt; {
    if p &lt;= 0. {
        return Err("Principal cannot be less or equal to zero".to_string());
    }

    if n &lt;= 0. {
        return Err("Number of years cannot be less or equal to zero".to_string());
    }

    if r &lt;= 0. {
        return Err("Rate cannot be less or equal to zero".to_string());
    }

    Ok((p * n * r) / 100.0)
}

fn si_using_option(p: f32, n: f32, r: f32) -&gt; Option&lt;f32&gt; {
    if p &lt;= 0. {
        return None;
    }

    if n &lt;= 0. {
        return None;
    }

    if r &lt;= 0. {
        return None;
    }

    Some((p * n * r) / 100.0)
}

fn main() {
    let p: f32 = 10000.0;
    let n: f32 = 0.0;
    let r: f32 = 1.4;

    match si_using_result(p, n, r) {
        Ok(result) =&gt; println!("si = {result}"),
        Err(e) =&gt; println!("Result ENUM - Error occured {:?}", e),
    }
    
    match si_using_option(p, n, r) {
        Some(result) =&gt; println!("si = {result}"),
        None =&gt; println!("Option ENUM - Error occurred: one of the inputs is non-positive"),
    }
}
</code></pre>
<h3 id="the--operator"><a class="header" href="#the--operator">The ? operator</a></h3>
<p><strong>? is used for Error Propogation</strong></p>
<p>There is an even shorter way to deal with Result (and Option), shorter than a match and even shorter than if let. It is called the "<strong>question mark operator</strong>."</p>
<p>After a function that returns a result, you can add ?. This will:</p>
<p>If its Ok, return the result</p>
<p>If its Err, return the error</p>
<pre><code>// 

fn calc_si(p: f32, n: f32, r: f32) -&gt; Result&lt;f32, String&gt; {
    if p &lt;= 0. {
        return Err("Principal cannot be less or equal to zero".to_string());
    }

    if n &lt;= 0. {
        return Err("Number of years cannot be less or equal to zero".to_string());
    }

    if r &lt;= 0. {
        return Err("Rate cannot be less or equal to zero".to_string());
    }

    Ok((p * n * r) / 100.0)
}

fn print_si(p: f32, n: f32, r: f32) -&gt; Result&lt;f32, String&gt;{
    let result_si = calc_si(p,n,r)?;
    Ok(result_si)
}

fn main() {
    let p: f32 = 10000.0;
    let n: f32 = 3.;
    let r: f32 = 1.4;

    println!("{:?}",print_si(p,n,r));

}
</code></pre>
<p>Skip the intermediate print_si function</p>
<pre><code>
fn si(p: f32, n: f32, r: f32) -&gt; Result&lt;f32, String&gt; {
    if p &lt;= 0. {
        return Err("Principal cannot be less or equal to zero".to_string());
    }

    if n &lt;= 0. {
        return Err("Number of years cannot be less or equal to zero".to_string());
    }

    if r &lt;= 0. {
        return Err("Rate cannot be less or equal to zero".to_string());
    }

    Ok((p * n * r) / 100.0)
}

fn main() -&gt; Result&lt;(), String&gt; {
    let p: f32 = 10000.0;
    let n: f32 = 3.0;
    let r: f32 = 1.4;

    let result = si(p, n, r)?;
    println!("si = {result}");
    Ok(())
}

</code></pre>
<h3 id="another-simple-example"><a class="header" href="#another-simple-example">Another Simple Example</a></h3>
<pre><code>// Simple Parse Example

fn parse_str(input: &amp;str) -&gt; Result&lt;i32, std::num::ParseIntError&gt; {
    let parsed_number = input.parse::&lt;i32&gt;()?;
    Ok(parsed_number)
}

fn main() {
    let str_vec = vec!["Seven", "8", "9.0", "nice", "6060"];
    for item in str_vec {
        let parsed = parse_str(item);
        println!("{:?}", parsed);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-map"><a class="header" href="#hash-map">Hash Map</a></h1>
<p>Data type to store data in Key - Value pair.</p>
<p>Keys are used to looking up corresponding values.</p>
<p>Example: Phone book - Search for the name and get the phone number</p>
<p>Under the hood, a hash function determines how to store data so the value can be quickly located.</p>
<p>In other languages, we have a similar feature.</p>
<p>Map / Dictionary / Associative Array</p>
<p><strong>Rules</strong></p>
<ul>
<li>All values must have the same data type.</li>
<li>Each key can only have one value associated with it at a time.</li>
<li>No duplicate keys.</li>
</ul>
<pre><code>// HashMap

use std::collections::HashMap;

fn main() {
    let mut cities = HashMap::new();
    cities.insert("Glassboro", 30000);
    cities.insert("Mullicahill", 25000);
    cities.insert("Swedesboro", 28000);
    
    //Option 1 - Update / Overwrite Existing Value
    //cities.insert("Glassboro", 31000);
    
    //Option 2 - Insert a new entry if it doesn't exist
    //cities.entry("Depford").or_insert(12000);
    
    //Option 3 - Get the value of the Key and perform a mathematical operation
    //let gpopulation = cities.entry("Glassboro").or_insert(0);
    //*gpopulation += 1;
    
    //print the hash map values. The print order may or may not be the same
    //as the insert. It changes from time to time.
    println!("cities is {:?}", cities);

    let glassboro_population = cities.get("Glassboro");
    
    if glassboro_population.is_some(){
        println!("glassboro_population is {:?}", glassboro_population);
    }
    else if glassboro_population.is_none(){
        println!("glassboro_population is not available", );
    }

    
    
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-alias"><a class="header" href="#type-alias">Type Alias</a></h1>
<p>A <em>type alias</em> defines a new name for an existing type. Type aliases are declared with the keyword <code>type.</code></p>
<p>Point to remember</p>
<p>The first letter of the type should be in upper case.</p>
<pre><code>// type alias

type Bannertype = u32;

fn main() {
    let mut id: Bannertype = 91615214;
    println!("{id}");
    id = 91615200;
    println!("{id}");
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>The Powerful module system can split the code into hierarchical logical units.</p>
<p>The module is a collection of items: functions, structs, and even other modules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module-sub-folders"><a class="header" href="#module-sub-folders">Module Sub Folders</a></h1>
<p>This way of organizing works for major projects.</p>
<p>The code in mod.rs is <strong>the content of that module.</strong> All other files in the folder may in turn be exposed as submodules.</p>
<p><code>cargo new moddemo3</code></p>
<p>create the following directory structure</p>
<figure><img src="chapter4/modules/../.gitbook/assets/module_multiple_folders.png" alt=""><figcaption></figcaption></figure>
<pre><code>// main.rs

mod departments;

fn main() {
    println!("{:?}", get_standard_greetings());
    departments::sales::meet_customer(1);
    departments::service::meet_customer(3);
}

fn get_standard_greetings() -&gt; String {
    return "Welcome to our store.".to_string();
}
</code></pre>
<pre><code>// departments &gt; mod.rs

fn get_number(num: i32) -&gt; String {
    match num {
        1 =&gt; return "123-456-7890".to_string(),
        2 =&gt; return "987-654-3210".to_string(),
        _ =&gt; return "000-000-0000".to_string(),
    }
}

pub mod sales;
pub mod service;
pub mod tests;
</code></pre>
<pre><code>// departments &gt; sales.rs

pub fn meet_customer(num: i32) {
    println!("Sales : meet customer {num}");
    let phone_number = super::get_number(num);
    println!("Sales calling {}", phone_number);
}

</code></pre>
<pre><code>// departments &gt; service.rs

pub fn meet_customer(num: i32) {
    println!("Service : meet customer {num}");
    let phone_number = super::get_number(num);
    let ticket_number = self::get_service_ticket_number(num);
    println!("Calling {phone_number} with ticket number {ticket_number}");
}

fn get_service_ticket_number(num: i32) -&gt; i32 {
    match num {
        1 =&gt; return 2452423,
        2 =&gt; return 2341332,
        _ =&gt; return 6868765,
    }
}
</code></pre>
<pre><code>// departments &gt; tests.rs

#[cfg(test)] // Only compiles when running tests
use crate::get_standard_greetings;

#[test]
fn test_customerphone() {
    assert_eq!("000-000-0000", super::get_number(4));
}

#[test]
fn test_standard_greeting() {
    assert_eq!("Welcome to our store.", get_standard_greetings());
}

</code></pre>
<p>Read more</p>
<p>{% embed url="https://spin.atomicobject.com/2022/01/24/rust-module-system/" %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module-multiple-files"><a class="header" href="#module-multiple-files">Module Multiple files</a></h1>
<p>cargo new moddemo2</p>
<p>create files as given below</p>
<figure><img src="chapter4/modules/../.gitbook/assets/module_multile_files.png" alt=""><figcaption></figcaption></figure>
<pre><code>// departments.rs

pub mod dept {
    fn get_number(num: i32) -&gt; String {
        match num {
            1 =&gt; return "123-456-7890".to_string(),
            2 =&gt; return "987-654-3210".to_string(),
            _ =&gt; return "000-000-0000".to_string(),
        }
    }

    pub mod sales {
        pub fn meet_customer(num: i32) {
            println!("Sales : meet customer {num}");
            let phone_number = super::get_number(num);
            println!("Sales calling {}", phone_number);
        }
    }

    pub mod service {
        pub fn meet_customer(num: i32) {
            println!("Service : meet customer {num}");
            let phone_number = super::get_number(num);
            let ticket_number = self::get_service_ticket_number(num);
            println!("Calling {phone_number} with ticket number {ticket_number}");
        }

        fn get_service_ticket_number(num: i32) -&gt; i32 {
            match num {
                1 =&gt; return 2452423,
                2 =&gt; return 2341332,
                _ =&gt; return 6868765,
            }
        }
    }

    #[cfg(test)] // Only compiles when running tests
    mod tests {
        use crate::get_standard_greetings;

        #[test]
        fn test_customerphone() {
            assert_eq!("000-000-0000", super::get_number(4));
        }

        #[test]
        fn test_standard_greeting() {
            assert_eq!("Welcome to our store.", get_standard_greetings());
        }
    }
}

</code></pre>
<pre><code>// main.rs


// Refer the external file
mod departments;

// Import the module
use departments::dept;

fn main() {
    println!("{:?}", get_standard_greetings());
    dept::sales::meet_customer(1);
    dept::service::meet_customer(3);
}

fn get_standard_greetings() -&gt; String {
    return "Welcome to our store.".to_string();
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-defined-module"><a class="header" href="#user-defined-module">User Defined Module</a></h1>
<p>The Powerful module system can split the code into hierarchical logical units.</p>
<p>The module is a collection of items: functions, structs, and even other modules.</p>
<p>By default, items in a module are private; they can be changed to the public by adding <strong>pub</strong> before it.</p>
<p>Simple example</p>
<pre><code>// Mod

mod sales{
    pub fn meet_customer(){
        println!("meet customer"); 
    }
       
}

fn main(){
    sales::meet_customer();
   
}
</code></pre>
<p>Pass params</p>
<pre><code>// Some code

    mod sales {
        pub fn meet_customer(num:i32) {
            println!("meet customer {num}");
        }
    }


fn main() {
    sales::meet_customer(1);
}
</code></pre>
<p>Companies have multiple depts so nesting the modules help in the hierarchy.</p>
<p>Note Sales module has to pub.</p>
<pre><code>
mod departments {
    pub mod sales {
        pub fn meet_customer(num:i32) {
            println!("meet customer {num}");
        }

    }
}

fn main() {
    departments::sales::meet_customer(1);
}

</code></pre>
<p>Exposing only limited functionality</p>
<pre><code>// Here meet_customer calls get_number as that function is not 
// not exposed to main function

mod departments {
    pub mod sales {
        pub fn meet_customer(num:i32,requestedby:&amp;str) {
            println!("meet customer {num}");
            let phone_number = get_number(num, requestedby);
            println!("calling {:?}", phone_number);
        }

        fn get_number(num:i32,requestedby:&amp;str) -&gt; String {
            println!("{requestedby}");
            let phonenumber = match num {
                1 =&gt; "123-456-7890".to_string(),
                2 =&gt; "987-654-3210".to_string(),
                _ =&gt; "000-000-0000".to_string()
            };
            
            if requestedby == "Manager"{
                return phonenumber
            }
            else if requestedby == "CustService"
            {
                return phonenumber[8..].to_string()
            }
            else{
                return "".to_string()
            }
        }
    }
}

fn main() {
    departments::sales::meet_customer(1,"Manager");
    departments::sales::meet_customer(1,"CustService");
}
</code></pre>
<p>Invoking the parent private function using super::</p>
<pre><code>// super::

mod departments {
    fn get_number(num:i32) -&gt; String {
        match num {
            1 =&gt; return "123-456-7890".to_string(),
            2 =&gt; return "987-654-3210".to_string(),
            _ =&gt; return "000-000-0000".to_string()
        }
    }


    pub mod sales {
        pub fn meet_customer(num:i32) {
            println!("Sales : meet customer {num}");
            let phone_number = super::get_number(num);
            println!("Sales calling {}", phone_number);
        }
    }

    pub mod service {
        pub fn meet_customer(num:i32) {
            println!("Service : meet customer {num}");
            let phone_number = super::get_number(num);
            println!("Service calling {}", phone_number);
        }
    }
}

fn main() {
    departments::sales::meet_customer(1);
    departments::service::meet_customer(3);
}
</code></pre>
<p>Example for self::</p>
<pre><code>// self::

mod departments {
    fn get_number(num:i32) -&gt; String {
        match num {
            1 =&gt; return "123-456-7890".to_string(),
            2 =&gt; return "987-654-3210".to_string(),
            _ =&gt; return "000-000-0000".to_string()
        }
    }


    pub mod sales {
        pub fn meet_customer(num:i32) {
            println!("Sales : meet customer {num}");
            let phone_number = super::get_number(num);
            println!("Sales calling {}", phone_number);
        }
    }

    pub mod service {
        pub fn meet_customer(num:i32) {
            println!("Service : meet customer {num}");
            let phone_number = super::get_number(num);
            let ticket_number = self::get_service_ticket_number(num);
            println!("Calling {phone_number} with ticket number {ticket_number}");
        }

        fn get_service_ticket_number(num:i32)-&gt;i32{
            match num {
                1 =&gt; return 2452423,
                2 =&gt; return 2341332,
                _ =&gt; return 6868765
            } 
        }
    }
}

fn main() {
    departments::sales::meet_customer(1);
    departments::service::meet_customer(3);
}


</code></pre>
<p>Putting it all together along with TEST Cases</p>
<pre><code>// With Test Cases

mod departments {
    fn get_number(num: i32) -&gt; String {
        match num {
            1 =&gt; return "123-456-7890".to_string(),
            2 =&gt; return "987-654-3210".to_string(),
            _ =&gt; return "000-000-0000".to_string(),
        }
    }

    pub mod sales {
        pub fn meet_customer(num: i32) {
            println!("Sales : meet customer {num}");
            let phone_number = super::get_number(num);
            println!("Sales calling {}", phone_number);
        }
    }

    pub mod service {
        pub fn meet_customer(num: i32) {
            println!("Service : meet customer {num}");
            let phone_number = super::get_number(num);
            let ticket_number = self::get_service_ticket_number(num);
            println!("Calling {phone_number} with ticket number {ticket_number}");
        }

        fn get_service_ticket_number(num: i32) -&gt; i32 {
            match num {
                1 =&gt; return 2452423,
                2 =&gt; return 2341332,
                _ =&gt; return 6868765,
            }
        }
    }

    #[cfg(test)] // Only compiles when running tests
    mod tests {
        use crate::get_standard_greetings;

        #[test]
        fn test_customerphone() {
            assert_eq!("000-000-0000", super::get_number(4));
        }

        #[test]
        fn test_standard_greeting() {
            assert_eq!("Welcome to our store.", get_standard_greetings());
        }
    }
}

fn main() {
    println!("{:?}", get_standard_greetings());
    departments::sales::meet_customer(1);
    departments::service::meet_customer(3);
}

fn get_standard_greetings() -&gt; String {
    return "Welcome to our store.".to_string();
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-library"><a class="header" href="#creating-a-library">Creating a Library</a></h1>
<p>Creating Binary (executable) files is one option; another option is to create your Library files.</p>
<p>lib.rs - is used to create a library crate.</p>
<h3 id="part-1-create-a-department-library"><a class="header" href="#part-1-create-a-department-library"><strong>Part 1: Create a Department library</strong></a></h3>
<p>To create a new library include --lib when creating a new cargo package </p>
<p>cargo new newlib --lib</p>
<figure><img src="chapter4/modules/../.gitbook/assets/library_module.png" alt=""><figcaption></figcaption></figure>
<pre><code>// departments.rs

pub mod dept {
    fn get_number(num: i32) -&gt; String {
        match num {
            1 =&gt; return "123-456-7890".to_string(),
            2 =&gt; return "987-654-3210".to_string(),
            _ =&gt; return "000-000-0000".to_string(),
        }
    }

    pub mod sales {
        pub fn meet_customer(num: i32) {
            println!("Sales : meet customer {num}");
            let phone_number = super::get_number(num);
            println!("Sales calling {}", phone_number);
        }
    }

    pub mod service {
        pub fn meet_customer(num: i32) {
            println!("Service : meet customer {num}");
            let phone_number = super::get_number(num);
            let ticket_number = self::get_service_ticket_number(num);
            println!("Calling {phone_number} with ticket number {ticket_number}");
        }

        fn get_service_ticket_number(num: i32) -&gt; i32 {
            match num {
                1 =&gt; return 2452423,
                2 =&gt; return 2341332,
                _ =&gt; return 6868765,
            }
        }
    } 
}

</code></pre>
<pre><code>// lib.rs

pub mod departments;
</code></pre>
<pre><code>// cargo build
</code></pre>
<h3 id="part-2-use-the-above-library"><a class="header" href="#part-2-use-the-above-library">Part 2: Use the above library</a></h3>
<pre><code>// from terminal

cargo new newlib-test
</code></pre>
<pre><code>// main.rs

use newlib::departments::dept;

fn main() {
    dept::sales::meet_customer(1);
    dept::service::meet_customer(3);
}
</code></pre>
<pre><code>// cargo.toml

[dependencies]
newlib = {path = "../newlib"}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-modules"><a class="header" href="#standard-modules">Standard Modules</a></h1>
<p>Like python/java/c/c++ Rust has standard modules which can be used for standard functionality.</p>
<p>Example:</p>
<p>The <code>std::io</code> the module contains a number of common things you’ll need when doing input and output.</p>
<p>Similarly when working with Files </p>
<pre><code>use std::fs::File;
</code></pre>
<p>can be used.</p>
<p>Refer to this page for a list of modules</p>
<p><a href="https://doc.rust-lang.org/std/io/index.html#modules">https://doc.rust-lang.org/std/io/index.html#modules</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-5"><a class="header" href="#chapter-5">Chapter 5</a></h1>
<ul>
<li><a href="chapter5/file-handling.html">file-handling</a></li>
<li><a href="chapter5/json.html">json</a></li>
<li><a href="chapter5/macros.html">macros</a></li>
<li><a href="chapter5/generics.html">generics</a></li>
<li><a href="chapter5/traits.html">traits</a></li>
<li><a href="chapter5/database.html">database</a></li>
<li><a href="chapter5/smart-pointers.html">smart-pointers</a></li>
<li><a href="chapter5/log4j.html">log4j</a></li>
<li><a href="chapter5/closures.html">closures</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>Rust provides a powerful macro system that allows metaprogramming. As you've seen in previous chapters, macros look like functions, except that their name ends with a bang !, but instead of generating a function call, macros are expanded into source code that gets compiled with the rest of the program.</p>
<p>Macros are created using the <strong>macro_rules!</strong> Macro.</p>
<p>() -- takes no argument ($argument: designator)</p>
<p><strong>Popular designators are</strong></p>
<p>expr is used for expressions </p>
<p>ty is used to type </p>
<p>ident is used for variable/function names</p>
<p><strong>Syntax</strong></p>
<pre><code>macro_rules! &lt;name of macro&gt;{
    () =&gt; {}
}
</code></pre>
<pre><code>() - Match for the pattern
{} - Expand the code / Body of the macro
</code></pre>
<pre><code>// Macro with No argument

macro_rules! print_hello {
    () =&gt; {
        // The macro will expand into the contents of this block.
        println!("Hello World");
    };
}

fn main() {
    print_hello!();
}
</code></pre>
<p><strong>Macro returning a constant value</strong></p>
<pre><code>// Macro returning value 10

macro_rules! ten {
    () =&gt; {5 + 5};
}

fn main(){
    println!("{}",ten!());
}
</code></pre>
<p><strong>Macro with one argument</strong></p>
<p>using <strong>expr</strong> designator</p>
<pre><code>// Macro with one argument

macro_rules! hi {
    ($name:expr) =&gt; {
        println!("Hello {}!",$name);
    };
}

fn main() {
    hi!("Rachel");
}
</code></pre>
<p><strong>Simple addition macro</strong></p>
<pre><code>// Takes two arguments

macro_rules! add{
    ($a:expr,$b:expr)=&gt;{
         {
            $a+$b
        }
    }
}

fn main(){
    let c = add!(1,2);
    println!("{c}");
}

</code></pre>
<p><strong>Demo Stringify</strong></p>
<pre><code>// Stringify
//In Rust, stringify! is a macro that takes a Rust expression 
//and converts it into a string literal 

fn main() {
    println!("{},{}",1+1,stringify!("1+1"));
}

</code></pre>
<p><strong>Macro with Expressions</strong></p>
<pre><code>// More Expressions

macro_rules! print_result {
    ($expression:expr) =&gt; {
        println!("{:?} = {:?}", stringify!($expression), $expression);
    };
}

fn main() {
    print_result!(1 + 1);

    // Recall that blocks are expressions too!
    print_result!({
        let x = 10; x * x + 2 * x - 1
    });
}
</code></pre>
<p>using <strong>expr</strong> and <strong>ty</strong> designators</p>
<pre><code>// multiple designators
// variables with different datatypes can be added using this macro

macro_rules! add_using{
    // using a ty token type for matching datatypes passed to the macro
    
    ($x:expr,$y:expr,$typ:ty)=&gt;{
        $x as $typ + $y as $typ
    }
}

fn main(){
    let i:u8 = 5;
    let j:i32 = 10;
    println!("{}",add_using!(i,j,i32));
}
</code></pre>
<p><strong>Repeat / Dynamic Arguments</strong></p>
<pre><code>($($v:expr),*)  - Here the star (*) will repeat the patterns inside $()
And comma is the separator.
</code></pre>
<pre><code>// Repeat / Dynamic number of arguments

macro_rules! hi {
    ($($name:expr),*) =&gt; {
        {
            //let mut n = Vec::new();
            $(
                println!("Hi {}!",$name);
            )*
        }
    };
}

fn main() {
    hi!("Rachel","Ross","Monica");
}
</code></pre>
<p>Remember vec! Macro?</p>
<p>Let's try to create our equivalent of it.</p>
<pre><code>// Creating vec! equivalent 

macro_rules! my_vec {
    (
        $( $name:expr ), * ) =&gt; {
        {
            let mut n = Vec::new();
            $( n.push($name); )*
            
            n
        }
    };
}

fn main() {
    println!("{:?}",my_vec!("Rachel","Ross","Monica"));
}
</code></pre>
<h3 id="repeat---with-numeric-arguments"><a class="header" href="#repeat---with-numeric-arguments">Repeat - with Numeric arguments</a></h3>
<pre><code>macro_rules! add_all{
    ($($a:expr) , *) =&gt; 
    {
    // initial value of the expression
    0
    // block to be repeated
    $(+$a)*
    }
}

//The * in $(+$a)* is a repetition operator, meaning 
//"repeat +$a for each $a matched".

fn main(){
    println!("{}",add_all!(1,2,3,4));
    //println!("{}",add_all!());
}
</code></pre>
<h3 id="compile-time-assertions"><a class="header" href="#compile-time-assertions">Compile time Assertions</a></h3>
<pre><code>
macro_rules! assert_equal_len {
    ($a:expr, $b:expr) =&gt; {
        assert!($a.len() == $b.len(), "Arrays must have the same length");
    };
}

fn main() {
    let a1 = [1, 2, 3];
    let a2 = [4, 5, 6];
    assert_equal_len!(a1, a2); // Compiles fine

    //let a3 = [7, 8];
    //assert_equal_len!(a1, a3); // This will fail to compile
}

</code></pre>
<h3 id="macro-overloading"><a class="header" href="#macro-overloading">Macro Overloading</a></h3>
<p>Overload to accept different combinations of arguments</p>
<pre><code>// `check!` will compare `$left` and `$right`
// in different ways depending on how you invoke it:

macro_rules! check {

    ($left:expr; and $right:expr) =&gt; {
        println!("{:?} and {:?} is {:?}",
                 stringify!($left), stringify!($right), $left &amp;&amp; $right)
    };

    ($left:expr; or $right:expr) =&gt; {
        println!("{:?} or {:?} is {:?}",
                 stringify!($left), stringify!($right), $left || $right)
    };
}

fn main() {
    check!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    check!(true; or false);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>A trait defines a particular type's functionality and can share with other types. We can use traits to define shared behavior abstractly.</p>
<p>Traits allow us to define interfaces or shared behaviors on types. To implement a trait for a type, we must implement methods of that trait.</p>
<p>When working with Structs, we have enabled Debug and Display traits. </p>
<p>Rust supports defining and using custom traits.</p>
<pre><code>// Display Struct without Trait

#[derive(Debug)]

struct Show {
    name: String,
    total_seasons: u8 
}

#[derive(Debug)]
struct Season {
    season_name: String,
    season_id: u8,
    year: u16
}


fn main(){
	let friends = Show {
		name:String::from("Friends"),
		total_seasons:10
	};

	let currseason = Season {
		season_name:String::from("Last Season"),
		season_id:10,
		year:2004
	};
	
	println!("{:?}", friends);
	println!("{:?}", currseason);
}

</code></pre>
<pre><code>// Implementing the same using Traits

struct Show {
    name: String,
    total_seasons: u8 
}

struct Season {
    season_name: String,
    season_id: u8,
    year: u16
}

//We will list the method signature for all the methods that a type 
// implementing the Info trait will need to have.

trait Info {
	// Any datatype that implements this "detail" trait will return a string.

	fn detail(&amp;self) -&gt; String;
}

impl Info for Show{
	fn detail(&amp;self) -&gt; String{
		format!("{} contains {} seasons",self.name,self.total_seasons)
	}
}

impl Info for Season{
	fn detail(&amp;self) -&gt; String{
		format!("you are watching {} ({}) telecasted in {}", self.season_name, self.season_id, self.year)
	}
}

fn main(){
	let friends = Show {
		name:String::from("Friends"),
		total_seasons:10
	};

	let currseason = Season {
		season_name:String::from("Last Season"),
		season_id:10,
		year:2004
	};
	
	
	println!("{}", friends.detail());
	println!("{}", currseason.detail());
}
</code></pre>
<h3 id="default-implementation"><a class="header" href="#default-implementation">Default Implementation</a></h3>
<p>In some cases, it's useful to have a default implementation for one or more of the methods in a trait.</p>
<p>Especially when you have a trait with many methods, you can implement only some of them for every datatype.</p>
<pre><code>// Default Trait

struct Show {
    name: String,
    total_seasons: u8 
}

struct Season {
    season_name: String,
    season_id: u8,
    year: u16
}


trait Info {
	fn detail(&amp;self) -&gt; String;

	fn description(&amp;self) -&gt; String {
		String::from("No description available")
	}
}

impl Info for Show{
	fn detail(&amp;self) -&gt; String{
		format!("{} contains {} seasons",self.name,self.total_seasons)
	}

}

impl Info for Season{
	fn detail(&amp;self) -&gt; String{
		format!("you are watching {} ({}) telecasted in {}", self.season_name, self.season_id, self.year)
	}

	fn description(&amp;self) -&gt; String{
		format!("Its the series finale episode.")
	}
}



fn main(){
	let friends = Show {
		name:String::from("Friends"),
		total_seasons:10
	};

	let currseason = Season {
		season_name:String::from("Last Season"),
		season_id:10,
		year:2004
	};
	
	
	println!("Friends - Detail : {}", friends.detail());
	println!("Current Season - Detail {}", currseason.detail());
    	println!("---------------------");
	println!("Printing Default Description : {}", friends.description());
	println!("Printing specific Description : {}", currseason.description());

}
</code></pre>
<h3 id="derivable-traits"><a class="header" href="#derivable-traits">Derivable Traits</a></h3>
<p>Provide default implementations for several common traits</p>
<p>The compiler will generate default code for the required methods when you derive traits.</p>
<p>If you need something specific, you'll need to implement the methods yourself.</p>
<p>List of commonly used derivable traits</p>
<ul>
<li>Eq </li>
<li>PartialEq </li>
<li>Ord </li>
<li>PartialOrd </li>
<li>Clone </li>
<li>Copy </li>
<li>Hash </li>
<li>Default </li>
<li>Debug</li>
</ul>
<pre><code>// Comparison

#[derive(PartialEq,PartialOrd)]

struct Show {
    name: String,
    total_seasons: u8 
}

fn main(){
	let friends = Show {
		name:String::from("Friends"),
		total_seasons:10
	};

	let bbt = Show {
		name:String::from("BBT"),
		total_seasons:12
	};
		
	println!("{}", friends == bbt);
	println!("{}", friends &gt; bbt);	

}

</code></pre>
<p>What if we need to have custom comparison on specific items</p>
<pre><code>// Custom Comparison

#[allow(dead_code)]

struct Show {
    name: String,
    total_seasons: u8,
}

// self = self: Self and &amp;self = self: &amp;Self

trait Comparison {
    fn eq(&amp;self, obj1:&amp;Self) -&gt; bool;
}

impl Comparison for Show {
    fn eq(&amp;self, obj1: &amp;Self) -&gt; bool {
        if self.total_seasons == obj1.total_seasons {
            true
        } else {
            false
        }
    }
}

fn main() {
    let friends = Show {
        name: String::from("Friends"),
        total_seasons: 10,
    };

    let bbt = Show {
        name: String::from("BBT"),
        total_seasons: 12,
    };

    println!("Custom Comparison {}", friends.eq(&amp;bbt));
}

</code></pre>
<h3 id="another-example-with-numerical-values"><a class="header" href="#another-example-with-numerical-values">Another Example with Numerical values</a></h3>
<pre><code>//declare a structure

struct Circle {
    radius: f32,
}

struct Rectangle {
    width: f32,
    height: f32,
}

struct Square {
    width: f32,
}

//declare a trait

trait Area {
    fn shape_area(&amp;self) -&gt; f32;
}

//implement the trait

impl Area for Square {
    fn shape_area(&amp;self) -&gt; f32 {
        self.width * self.width
    }
}

impl Area for Circle {
    fn shape_area(&amp;self) -&gt; f32 {
        3.14 * self.radius * self.radius
    }
}

impl Area for Rectangle {
    fn shape_area(&amp;self) -&gt; f32 {
        self.width * self.height
    }
}

fn main() {
    //create an instance of the structure
    let c = Circle { radius: 2.0 };

    let r = Rectangle {
        width: 2.0,
        height: 2.0,
    };

    let s = Square { width: 5.0 };

    println!("Area of Circle: {}", c.shape_area());
    println!("Area of Rectangle:{}", r.shape_area());
    println!("Area of Rectangle:{}", s.shape_area());
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p><strong>Monomorphization</strong> is a process where the compiler replaces generic placeholders with concrete datatypes.</p>
<p>Generics are a way to make a function or a type work for multiple types to avoid code duplication.</p>
<ul>
<li>Doesn't affect Runtime Performance. </li>
<li>Generics are a zero-cost abstraction. </li>
<li>Make Programming easier without reducing runtime performance.</li>
</ul>
<pre><code>// Some code

use std::fmt::Debug;
use std::fmt::Display;
use std::ops::*;

fn main() {
    //i32
    let n1: i32 = 10;
    let n2: i32 = 20;
    print_this(n1, n2);
    
    println!("Adding i32 ( {} + {} ) = {}", n1,n2, add_values(n1, n2));
    println!("Subtracting i32 ( {} from {} ) = {}", n1,n2,sub_values(n1, n2));
    println!("-----------------------------------");

    // F64
    let t1 = 23.45;
    let t2 = 34.56;
    print_this(t1, t2);

    println!("Adding f64 ( {} + {} ) = {}", t1,t2, add_values(t1, t2));
    println!("Subtracting f64 ( {} from {} ) = {}", t1,t2,sub_values(t1, t2));
    println!("-----------------------------------");

    // &amp;str
    let r1 = "Rachel";
    let r2 = "Green";
    print_this(r1, r2);
    println!("----------------");

    // String Object
    let s1 = String::from("Rachel");
    let s2 = String::from("Green");
    print_this(s1, s2);
    println!("----------------");
    
    //printing diff datatypes
    
    print_another(t1,n1);

}


fn print_this&lt;T: Debug + Display&gt;(p1: T, p2: T) -&gt; () {
    println!("Printing - {:?},{}", p1, p2)
}

fn add_values&lt;T: Add&lt;Output = T&gt;&gt;(p1: T, p2: T) -&gt; T {
    // ://doc.rust-lang.org/std/ops/index.html
    p1 + p2
}

fn sub_values&lt;T: Sub&lt;Output = T&gt;&gt;(p1: T, p2: T) -&gt; T {
    p1 - p2
}

fn print_another&lt;T: Debug + Display, U:Debug + Display&gt;(p1: T, p2: U) -&gt; () {
    println!("Printing Diff Datatypes - {:?},{}", p1, p2)
}
</code></pre>
<h3 id="generics-with-struct"><a class="header" href="#generics-with-struct">Generics with Struct</a></h3>
<pre><code>// Generics with Struct

struct Sample&lt;T, U, V&gt; {
    a: T,
    b: U,
    c: V
}

fn main() {
    let var1 = Sample{ a: 43.10, b: 2, c:"Hello" };
    println!("A: {}", var1.a);
    println!("B: {}", var1.b);
    println!("C: {}", var1.c);

    println!("----------------");

    let var2 = Sample{ a: "Hello", b: "World", c:34.6 };
    println!("A: {}", var2.a);
    println!("B: {}", var2.b);
    println!("C: {}", var2.c);
}


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="description-java-script-object-notation"><a class="header" href="#description-java-script-object-notation">description: Java Script Object Notation</a></h2>
<h1 id="json"><a class="header" href="#json">JSON</a></h1>
<p>The flexible way to store &amp; share data across systems. It's a text file with curly braces &amp; key-value pairs { }</p>
<p>Simplest JSON format</p>
<pre><code>{"id": "1","name":"Rachel"}
</code></pre>
<h3 id="properties"><a class="header" href="#properties">Properties</a></h3>
<p>Language Independent.</p>
<p>Self-describing and easy to understand.</p>
<h3 id="basic-rules"><a class="header" href="#basic-rules">Basic Rules</a></h3>
<p>Curly braces to hold the objects.</p>
<p>Data is represented in Key-Value or Name-Value pairs.</p>
<p>Data is separated by a comma.</p>
<p>The use of double quotes is necessary.</p>
<p>Square brackets [ ] hold an array of data.</p>
<h3 id="json-values"><a class="header" href="#json-values">JSON Values</a></h3>
<pre><code>String  {"name":"Rachel"}

Number  {"id":101}

Boolean {"result":true, "status":false}  (lowercase)

Object  {
            "character":{"fname":"Rachel","lname":"Green"}
        }

Array   {
            "characters":["Rachel","Ross","Joey","Chanlder"]
        }

NULL    {"id":null}
</code></pre>
<h3 id="sample-json-document"><a class="header" href="#sample-json-document">Sample JSON Document</a></h3>
<pre><code>{
    "characters": [
        {
            "id" : 1,
            "fName":"Rachel",
            "lName":"Green",
            "status":true
        },
        {
            "id" : 2,
            "fName":"Ross",
            "lName":"Geller",
            "status":true
        },
        {
            "id" : 3,
            "fName":"Chandler",
            "lName":"Bing",
            "status":true
        },
        {
            "id" : 4,
            "fName":"Phebe",
            "lName":"Buffay",
            "status":false
        }
    ]
}
</code></pre>
<h3 id="json-best-practices"><a class="header" href="#json-best-practices">JSON Best Practices</a></h3>
<p><strong>No Hyphen in your Keys.</strong></p>
<pre><code>{"first-name":"Rachel","last-name":"Green"}  is not right. ✘
</code></pre>
<p><strong>Under Scores Okay</strong></p>
<pre><code>{"first_name":"Rachel","last_name":"Green"} is okay ✓
</code></pre>
<p>L<strong>owercase Okay</strong></p>
<pre><code>{"firstname":"Rachel","lastname":"Green"} is okay ✓
</code></pre>
<p><strong>Camelcase best</strong></p>
<pre><code>{"firstName":"Rachel","lastName":"Green"} is the best. ✓
</code></pre>
<h3 id="json--rust"><a class="header" href="#json--rust">JSON &amp; RUST</a></h3>
<ul>
<li>The <strong>Deserialize</strong> trait is required to parse (that is, read) JSON strings into this Struct.</li>
<li>The <strong>Serialize</strong> trait is required to format (that is, write) this Struct into a JSON string.</li>
<li>The <strong>Debug</strong> trait is for printing a Struct on a debug trace.</li>
</ul>
<pre><code>// main.rs

use serde_derive::{Deserialize, Serialize};
use std::env;
use std::fs;

// Remember attributes should be below the use statements

#[allow(non_snake_case)]

#[derive(Deserialize, Serialize, Debug)]
struct Characters {
    id: u32,
    fName: String,
    lName: String,
    status: bool
}

#[derive(Deserialize, Serialize, Debug)]
struct CharacterArray {
    characters: Vec&lt;Characters&gt;
}

fn main()  {
    let input_path = env::args().nth(1).unwrap();
    //let output_path = env::args().nth(2).unwrap();

    let friends = {
        let jsondata = fs::read_to_string(&amp;input_path).unwrap();
        // Load the Friends structure from the string.
        serde_json::from_str::&lt;CharacterArray&gt;(&amp;jsondata).unwrap()
    };
    
    for index in 0..friends.characters.len() {
        println!("{} - {}",friends.characters[index].fName,friends.characters[index].lName);
    }
}


</code></pre>
<p>save  the above json document as sample.json</p>
<figure><img src="chapter5/.gitbook/assets/json_sample.png" alt=""><figcaption></figcaption></figure>
<pre><code>// cargo.toml

[dependencies]
serde = "1.0.147"
serde_derive = "1.0.147"
serde_json = "1.0.87"

</code></pre>
<h3 id="convert-struct-to-json"><a class="header" href="#convert-struct-to-json">Convert Struct to JSON</a></h3>
<pre><code>use serde_derive::{Serialize};

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]

struct Person {
    first_name: String,
    last_name: String,
    id: i32,
    status: bool
}

fn main() {
    let person = Person {
        first_name: "Rachel".to_string(),
        last_name: "Green".to_string(),
        id: 1,
        status:true
    };

    let person1 = Person {
        first_name: "Monica".to_string(),
        last_name: "Geller".to_string(),
        id: 2,
        status:true
    };
    
    let v = vec![&amp;person,&amp;person1];

    let output_path = "sample_output.json";

    let json = serde_json::to_string_pretty(&amp;v).unwrap();  // &lt;- unwrap

    println!("{}", json);
    
    std::fs::write(
        output_path,
        json,
    ).unwrap()
}
</code></pre>
<pre><code>// cargo.toml

serde = "1.0.147"
serde_derive = "1.0.147"
serde_json = "1.0.87"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-handling"><a class="header" href="#file-handling">File Handling</a></h1>
<p>FS Module is not part of the default prelude.</p>
<p><strong>Rust Prelude</strong></p>
<p>The prelude is the list of things that Rust automatically imports into every Rust program. It’s kept as small as possible and is focused on things, particularly traits, which are used in almost every single Rust program.</p>
<p>The Data file should be in the same level src folder.</p>
<figure><img src="chapter5/.gitbook/assets/file_handling.png" alt=""><figcaption><p>data.txt should be at the same level src folder</p></figcaption></figure>
<h3 id="-1"><a class="header" href="#-1"></a></h3>
<pre><code>// data.txt

Rachel
Monica
Phoebe
Chandler
Joey
Ross
</code></pre>
<h3 id="read-file"><a class="header" href="#read-file">Read File</a></h3>
<pre><code>// main.rs

use std::fs;

fn main(){
	let contents = fs::read_to_string("data.txt").unwrap();
	println!("{:?}",contents);
}
</code></pre>
<h3 id="read-line-by-line"><a class="header" href="#read-line-by-line">Read Line by Line</a></h3>
<pre><code>use std::fs;

fn main(){
	let contents = fs::read_to_string("data.txt").unwrap();
	for line in contents.lines(){
		println!("{}",line);
	}
}
</code></pre>
<p>Rust can also read nontext files (such as images and  binaries) </p>
<p>It reads as a vector of u8.</p>
<pre><code>// Read as vector of u8

use std::fs;

fn main(){
	let contents = fs::read("data.txt").unwrap();
	println!("{:?}", contents);
}
</code></pre>
<h3 id="write-file"><a class="header" href="#write-file">Write File</a></h3>
<pre><code>// Write a simple file

use std::fs;

fn main() {
    let mut text = String::new();
    text.push_str("Rust is strong and statically typed language.");
    text.push_str("Rust is super strict.");
   
    fs::write("newfile.txt",text);
}
</code></pre>
<h3 id="points-to-remember"><a class="header" href="#points-to-remember">Points to remember</a></h3>
<p>Simple to use</p>
<p>Will replace the contents of an existing file</p>
<p>Writes entire contents of the file.</p>
<p><strong>How to append</strong> </p>
<pre><code>use std::fs;
use std::io::prelude::*;

fn main() {
    let mut text = String::new();
    text.push_str("Rust is strong and statically typed language.");
    text.push_str("Rust is super strict.");

    //fs::write("newfile.txt",text);

    let mut file = fs::OpenOptions::new().append(true).open("newfile.txt").unwrap();
    file.write(b"Rust is awesome");
}

</code></pre>
<p>Write fn doesn't care about datatype. It thinks data is a series of bytes and it expects the value to be an array of u8 values.</p>
<h3 id="simple-find-command-line-simulator"><a class="header" href="#simple-find-command-line-simulator">Simple Find Command Line simulator</a></h3>
<pre><code>// friends.txt

Rachel
Monica
Phoebe
Chandler
Joey
Ross
</code></pre>
<pre><code>//cargo run friends.txt Ross

use std::env;
use std::fs;

fn main() {
    if env::args().len() &lt; 2 {
        eprintln!("Program requires two arguments: &lt;file path&gt; &lt;search name&gt;");
        std::process::exit(1);
    }
    let file_path = env::args().nth(1).unwrap();
    let search_name = env::args().nth(2).unwrap();

    let contents = fs::read_to_string(file_path).unwrap();
    
    for line in contents.lines() {
        if line == search_name {
            println!("{} is part of Friends show", search_name);
            return;
        }
    }

    println!("{} is not a part of Friends show!", search_name);
}
</code></pre>
<p>Good resource if you want to recreate standard Linux commands using RUST</p>
<p><a href="https://doc.rust-lang.org/rust-by-example/std_misc/fs.html">https://doc.rust-lang.org/rust-by-example/std_misc/fs.html</a></p>
<p>You will come across few new notations like OK, Err we will read about them in the coming weeks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="log4j"><a class="header" href="#log4j">Log4J</a></h1>
<p>Log4j is a popular logging library for Java and is widely used in Java-based applications. It is famous for several reasons, including its ability to output logs in various formats, its support for customizable log levels, and its ability to integrate with other logging frameworks.</p>
<p>It started as a logging tool for Java, which eventually became a de facto standard in the industry.</p>
<p>Rust developers wrote a wrapper around those .jar files and made it available for Rust also.</p>
<p><a href="https://github.com/Better-Player/log4j-rs">https://github.com/Better-Player/log4j-rs</a></p>
<p>Several tools can be used to view the Logs generated by log4j.</p>
<p>LogViewPlus <a href="https://www.logviewplus.com/log-viewer.html">https://www.logviewplus.com/log-viewer.html</a></p>
<p>Another one  <a href="https://www.xplg.com/log4j-viewer-analyzer/">https://www.xplg.com/log4j-viewer-analyzer/</a></p>
<p>Apart from this, there are a lot of Big Data Real-time log viewers, such as</p>
<p>Splunk</p>
<p>Logstash</p>
<p>-------</p>
<p><strong>Appenders</strong> route log messages to different destinations, such as a log file, the console, or a network socket.</p>
<pre><code>// cargo.toml

[dependencies]
log="0.4.17"
log4rs = "1.2.0"
</code></pre>
<pre><code>// main.rs

use log::{error,info,warn,trace,debug, LevelFilter, SetLoggerError};
use log4rs::{
	append::{
		console::{ConsoleAppender},
		file::FileAppender,		
	},
	config::{Appender, Root,Config,Logger},
	encode::pattern::PatternEncoder,
    encode::json::JsonEncoder,
};

fn main() -&gt; Result&lt;(), SetLoggerError&gt;  {

    // https://docs.rs/log4rs/latest/log4rs/encode/pattern/
    let stdout = ConsoleAppender::builder()
                    //.encoder(Box::new(JsonEncoder::new()))
                    .encoder(Box::new(PatternEncoder::new("{d} {h({l})} - {f} Line:{L} - {t} - {m}{n}")))
                    .build();

    let tofile = FileAppender::builder()
                    .encoder(Box::new(PatternEncoder::new("{d} {h({l})} - {f} Line:{L} - {t} - {m}{n}")))
                    .encoder(Box::new(JsonEncoder::new()))
                    .build("log/requests.log")
                    .unwrap();

    let config = Config::builder()
                    .appender(Appender::builder().build("stdout", Box::new(stdout)))
                    .appender(Appender::builder().build("save_to_file", Box::new(tofile)))
                    
                    .logger(Logger::builder()
                        .appender("save_to_file")
                        .additive(false)
                        .build("requests", LevelFilter::Warn))

                    .logger(Logger::builder()
                        .appender("stdout")
                        .additive(false)
                        .build("stdout", LevelFilter::Warn))

                    .build(
                        Root::builder()
                            .appender("stdout")
                            .appender("save_to_file")
                            .build(LevelFilter::Trace)
                        )
                    .unwrap();

    let _handle = log4rs::init_config(config).unwrap();

    //

    info!("Just FYI");
    error!("Used when reporting errors / panic situations.");
    warn!("Non Critical messages");
    debug!("Use this when debugging scripts");
    trace!("This is also used when debugging scripts. The difference is the granularity trace offers.");

    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<h2 id="box"><a class="header" href="#box">Box</a></h2>
<p>A good use case for the Box type in Rust programming is when you have a large data structure that you want to <strong>store on the heap rather than on the stack</strong>. </p>
<p>The Box type allows you to store the data on the heap in a safe and efficient way.</p>
<p>One reason why using a <strong>Box might be beneficial</strong> is that it can <strong>help you avoid stack overflows</strong>. The stack is a fixed-size data structure, so if you try to store a large data structure on the stack, it can overflow and cause your program to crash. </p>
<figure><img src="chapter5/.gitbook/assets/toy_box.png" alt=""><figcaption><p>Toy Box</p></figcaption></figure>
<p>What do you think about using a Toy Box?</p>
<p>Rust has a Smart Pointer called Box&lt;T&gt;. It allows developers to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data.</p>
<p>Boxes don't have performance overhead other than storing their data on the heap instead of on the stack.</p>
<pre><code>// Silly use case for Box

fn main() {
    let c = 4;
    let c1 = Box::new(c);
    println!("{},{}", c,c1);
}
</code></pre>
<pre><code>fn main() {

    let large_array: [i32; 5] = [1,2,3,4,5];
    let large_array1: Box&lt;[i32; 5]&gt; = Box::new([1, 2, 3, 4, 5]);

    println!("Stack Memory Location of variable large_array : {:p} {:p} {:?}", &amp;large_array, large_array.as_ptr(), large_array);
    
    println!("Heap Memory Location of variable large_array1 : {:p} {:p} {:?}", &amp;large_array1,  large_array1.as_ptr(), large_array1);
    
    
}

</code></pre>
<pre><code>// Better use case for using Box

use std::mem;

#[allow(dead_code)]
#[derive(Debug)]

struct Class {
    id: i32,
    fname: String,
    lname: String,
}

fn main() {
    let c = Class {
        id: 34,
        fname: String::from("Rachel"),
        lname: String::from("Green"),
    };

    println!{"{:?}", c};

    // Find the Size of the Variable in the Stack
    println!("Class size on stack: {} bytes", mem::size_of_val(&amp;c));

    let boxed_class: Box&lt;Class&gt; = Box::new(c);
    // Size of the Boxed Variable in Stack pointing to Heap.
    println!("boxed_class size on stack: {} bytes", mem::size_of_val(&amp;boxed_class));

    // Size of the Boxed Variable in Heap
    println!("boxed_class size on heap: {} bytes", mem::size_of_val(&amp;*boxed_class));

    //let unbox_class: Class = *boxed_class;
    //println!("unbox class size on stack: {} bytes", mem::size_of_val(&amp;unbox_class));

}
</code></pre>
<pre><code>// Stack to Heap

#[allow(dead_code)]
#[derive(Debug)]
struct Class {
    id: i32,
    fname: String,
    lname: String,
}

fn main() {
    let c = Class {
        id: 34,
        fname: String::from("Rachel"),
        lname: String::from("Green"),
    };
    
    let a = 10;
    let s = String::from("Hello");
    
    // Stack
    println!("Sample Stack location {:p}", &amp;a);
    // Heap
    println!("Sample Heap location {:p}", s.as_ptr());

    println!("\nBefore Boxing the Struct \n");
    println!("Stack Memory Location of Struct variable c : {:p}\nStruct Value : {:?}", &amp;c, c);
    println!("Stack Location of c.id : {:p}", &amp;c.id);
    println!("Stack c.fname pointing to : {:p} \nHeap c.fname {:p}", &amp;c.fname,c.fname.as_ptr());
    println!("Stack c.lname pointing to : {:p} \nHeap c.lname {:p}", &amp;c.lname,c.lname.as_ptr());
    
    println!("\nAfter Boxing the Struct \n");
    let b = Box::new(Class {
        id: 34,
        fname: String::from("Rachel"),
        lname: String::from("Green"),
    });
    println!("Heap Memory Location  {:p}\nStruct Value {:?}", b, b);
    println!("\n");
    println!("Heap Location of b.id : {:p}", &amp;b.id);
    println!("Heap b.fname pointing to : {:p} \nHeap Location b.fname {:p}",&amp;b.fname,b.fname.as_ptr());
    println!("Heap b.lname pointing to : {:p} \nHeap Location b.lname {:p}",&amp;b.lname,b.lname.as_ptr());
}

</code></pre>
<p>Linked List Example</p>
<pre><code>// Linked List

Here is an example of a linked list that could be stored on the stack in Rust:

struct Node {
    value: i32,
    next: Option&lt;Box&lt;Node&gt;&gt;,
}

struct LinkedList {
    head: Option&lt;Box&lt;Node&gt;&gt;,
}
</code></pre>
<p>In this example, the Node struct represents a single node in the linked list, and the LinkedList struct represents the entire linked list. The head field of the LinkedList struct contains a reference to the first node in the list, and each Node struct has a next field that contains a reference to the next node in the list.</p>
<p>Because this data structure is relatively small, it can be stored on the stack without problems. However, if the linked list became very large, it could cause a stack overflow, in which case it would be better to store it on the heap using a Box type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p><strong>Rust closures are anonymous functions</strong> without any name that you can save in a variable or pass as arguments to other functions.</p>
<p>Also called headless functions.</p>
<p>| | represents its a Closure.</p>
<pre><code>// Simple Closure Example

fn main() {
    let example = |num| -&gt; i32 { num + 1 };
    println!("{}", example(5));
}
</code></pre>
<h3 id="function-vs-closure"><a class="header" href="#function-vs-closure">Function vs. Closure</a></h3>
<pre><code>// Function vs Closure

fn add_one_fn(x: i32) -&gt; i32 {
    1 + x
}

fn main() {
    //let y = 6;
    
    let add_one_cl = |x: i32| -&gt; i32 { 1 + x};
    
    println!("Closure : {}", add_one_cl(3));
    
    println!("Function : {}", add_one_fn(3));
}

</code></pre>
<p>Unlike functions, closures can capture values from the scope in which they're called.</p>
<p>One more example</p>
<pre><code>// Closure returns a value

fn main() {
    let s = String::from("Hello");

    let closure = |name: String| -&gt; String {
        format!("{}, {}!", s, name)
    };

    let result = closure(String::from("Rachel"));
    
    println!("The result is: {}", result);
}
</code></pre>
<pre><code>// Mutable Values inside Closure

fn main() {
    let plus_two = |x| {
        let mut result: i32 = x;

        result += 1;
        result += 1;

        result
    };

    println!("{}", plus_two(2));
}

</code></pre>
<h3 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h3>
<ul>
<li>Creating functions that can be passed around and used in different parts of your code without explicitly defining the function in every place you want to use it. </li>
<li>This can make your code more modular and easier to understand. </li>
<li>Capturing variables from the environment and using them in the closure's code. </li>
<li>This allows you to create functions that can access and use values from the scope in which they are defined, even after the code that defined the closure has finished executing. </li>
<li>Implementing complex behavior for a type without creating a new struct or type. For example, you can use a closure to define the behavior of a trait object, which allows you to define complex behavior without creating a new type to represent that behavior.</li>
<li>Creating a  higher-order function takes other functions as arguments and  return other functions as results. </li>
</ul>
<p>Overall, closures are a very useful tool in Rust, and they can be used to solve a wide range of problems in your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database"><a class="header" href="#database">Database</a></h1>
<p>Why use System Programming language for Database Development?</p>
<p>Rust is known for its safety and performance, which makes it great for database applications.</p>
<ol>
<li><strong>Drivers and ORMs</strong>: Rust has solid drivers for major databases like PostgreSQL, MySQL, and SQLite. You've got ORMs (Object-Relational Mappers) like <code>Diesel</code> which makes database interactions more Rust-like and safe.</li>
<li><strong>Async/Await</strong>: Rust's async programming model works well with databases, especially for web apps. Libraries like <code>tokio-postgres</code> offer async database access.</li>
<li><strong>Safety and Concurrency</strong>: Rust's focus on safety and its powerful concurrency model can help prevent common database-related bugs, like race conditions.</li>
<li><strong>Custom Database Systems</strong>: Some folks even build custom database systems in Rust, thanks to its low-level control and efficiency.</li>
<li><strong>Web Frameworks Integration</strong>: With Web frameworks like Actix and Rocket, integrating databases into web applications is straightforward in Rust.</li>
</ol>
<p><strong>Free</strong> Cloud-based Databases (MySQL, PostgreSQL, CouchDB, RabbitMQ)</p>
<p><a href="https://www.alwaysdata.com/en/register/?d">https://www.alwaysdata.com/en/register/?d</a> <br />
<br />
------</p>
<h3 id="read-environment-variables"><a class="header" href="#read-environment-variables">Read Environment Variables</a></h3>
<pre><code>// SET Environment Variables

// Linux or MAC

// export MY_POSTGRESQL_USERID=value

// Windows

// Goto Environment Variables and Add

fn main() {
    println!("{}",std::env::var("MY_POSTGRESQL_USERID").unwrap());
}

</code></pre>
<p>cargo.toml</p>
<pre><code>postgres="0.19.4"

</code></pre>
<pre><code>
use postgres::{Client, Error, NoTls};

fn main() -&gt; Result&lt;(), Error&gt; {

    // clearscreen::clear().expect("failed to clear screen");

    let postgresql_userid = std::env::var("MY_POSTGRESQL_USERID").unwrap();
    let postgresql_pwd = std::env::var("MY_POSTGRESQL_PWD").unwrap();

    let conn_str = format!("postgresql://{postgresql_userid}:{postgresql_pwd}@postgresql-dbworldgc.alwaysdata.net:5432/dbworldgc_pg");

    let mut client = Client::connect(&amp;conn_str, NoTls)?;

    client.batch_execute(
        "
    CREATE TABLE if not exists sitcoms (
        id      SERIAL PRIMARY KEY,
        name    TEXT NOT NULL,
        genre    TEXT NULL
    )
",
    )?;

        
    //INSERT

    // let name = "Friends";
    // let genre = "RomCom";

    // client.execute(
    //     "INSERT INTO sitcoms (name, genre) VALUES ($1, $2)", &amp;[&amp;name, &amp;genre],
    // )?;

    //UPDATE

    // let genre = "Comedy";
    // let id = 2;

    // client.execute(
    //      "UPDATE sitcoms SET genre = $2 WHERE id = $1", &amp;[&amp;id, &amp;genre],
    // )?;

    //DELETE

    // let id = 1;
    // client.execute(
    //     "DELETE FROM sitcoms WHERE id = $1", &amp;[&amp;id],
    // )?;


    // Multiple Rows Insert

    // let tup_arr = [("Seinfeld","Standup"),("Charmed","Drama")];

    // for row in tup_arr{
    //     client.execute(
    //         "INSERT INTO sitcoms (name, genre) VALUES ($1, $2)", &amp;[&amp;row.0, &amp;row.1],
    //     )?;
    //     println!("Inserting --- {},{}",row.0,row.1);
    // }

    // Read the Value

    // for row in client.query("SELECT id, name, genre FROM sitcoms", &amp;[])? {
    //     let id: i32 = row.get(0);
    //     let name: &amp;str = row.get(1);
    //     let genre: &amp;str = row.get(2);
    //     println!("---------------------------------");
    //     println!("{} | {} | {:?}", id, name, genre);
    // }


    // #[derive(Debug)]
    // struct Sitcom {
    //     id: i32,
    //     name: String,
    //     genre: Option&lt;String&gt;, // Use Option for nullable fields
    // }


    // Read the Value and store in a vector
    // let mut sitcoms: Vec&lt;Sitcom&gt; = vec![];
    
    // for row in client.query("SELECT id, name, genre FROM sitcoms", &amp;[])? {
    //     let sitcom = Sitcom {
    //         id: row.get(0),
    //         name: row.get(1),
    //         genre: row.get(2),
    //     };
    //     sitcoms.push(sitcom);
    // }

    // // Print the sitcoms vector
    // for sitcom in sitcoms {
    //     println!("{:?}", sitcom);
    // }


    Ok(())
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nice-to-know"><a class="header" href="#nice-to-know">Nice to Know</a></h1>
<ul>
<li><a href="nice-to-know/big-o-notation.html">big-o-notation</a></li>
<li><a href="nice-to-know/important-concepts.html">important-concepts</a></li>
<li><a href="nice-to-know/cargo-publish.html">cargo-publish</a></li>
<li><a href="nice-to-know/cargo-watch.html">cargo-watch</a></li>
<li><a href="nice-to-know/cargo-audit.html">cargo-audit</a></li>
<li><a href="nice-to-know/cargo-profiles.html">cargo-profiles</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-publish"><a class="header" href="#cargo-publish">Cargo Publish</a></h1>
<p>Note: Once you publish a crate, there is no removal.</p>
<p>Visit <a href="https://crates.io/">https://crates.io/</a></p>
<p>Login with GitHub</p>
<p>Verify the email address</p>
<p>Goto Account &gt; API Settings and Generate a new token.</p>
<pre><code>// lib.rs

use std::fmt::Display;
use std::fmt::Debug;

/// Function hello accepts an argument and returns Hello &lt;argument&gt; !.
/// It accepts any scalar datatype (i,u,&amp;str,String,bool) and returns a String object.
/// This is a simple implementation to demonstrate Generics Function.
/// 
pub fn hello&lt;T:Display + Debug&gt;(s: T) -&gt; String {
    format!("Hello {} !", s.to_string() )
}


</code></pre>
<pre><code>// Cargo.toml

[package]
name = "hello_lib"
version = "0.1.6"
edition = "2021"
authors = ["Ganesh Chandrasekaran"]
description = "Demonstrate Generics Function"
documentation = "https://docs.rs/hello_lib"
readme="README.md"
license = "MIT"
keywords = ["demo", "generics","functions"]
categories = ["text-processing"]
repository = "https://github.com/gchandra10/hello_lib/"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>Create README.md at the same level as src folder</p>
<pre><code>// README.md

## Library for demonstration

## Usage

```
    // Cargo.toml

    [dependencies]
    hello_lib = "0.1.6"
```

```
    // main.rs

    use hello_lib::hello;

    fn main() {
        println!("{}", hello("Rachel"));
        println!("{}", hello(31));
        println!("{}", hello(3.14));
        println!("{}", hello(true));
        println!("{}", hello('G'));
    }

```
</code></pre>
<pre><code>// Cargo Commands

cargo login &lt;token&gt;
cargo publish --dry-run
</code></pre>
<pre><code>// git commands

git add Cargo.toml
git add README.md
git add src/lib.rs
git add .gitignore

git commit -m "Demo Crate"
</code></pre>
<pre><code>// Publish

cargo publish
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-watch"><a class="header" href="#cargo-watch">Cargo Watch</a></h1>
<p>This enables dynamic compilation as soon as the project is saved. This helps to save compilation time.</p>
<p>Goto command prompt or terminal and </p>
<pre><code>// How to install Cargo Watch

cargo install cargo-watch

</code></pre>
<p>Goto respective project</p>
<p>Dynamic Build</p>
<pre><code>cargo watch -x check
</code></pre>
<p>Dynamic Build and Run</p>
<pre><code>cargo watch -x check -x run
</code></pre>
<p>Dynamic Build, Run and Test</p>
<pre><code>cargo watch -x check -x run -x test
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="big-o-notation"><a class="header" href="#big-o-notation">Big O Notation</a></h1>
<h3 id="algorithmic-complexity"><a class="header" href="#algorithmic-complexity">Algorithmic Complexity</a></h3>
<p>When analyzing an algorithm,</p>
<p><strong>Time Complexity</strong>: The time it takes to execute the code.</p>
<p><strong>Space Complexity</strong>: The space taken in the memory to execute the code.</p>
<p>Following Notations are used to represent Algorithmic Complexity. Big O is what everybody is interested in.</p>
<p>Big - Omega = Best Case</p>
<p>Big - Theta = Average Case</p>
<p><strong>BIG O = Worst Case</strong></p>
<figure><img src="nice-to-know/../.gitbook/assets/00_common_complexities.png" alt=""><figcaption></figcaption></figure>
<p>Will try to use general algorithms not any specific programming syntaxes.</p>
<p><strong>Constant or Static Complexity - O(1)</strong></p>
<pre><code>// Constant / Static

print("Enter Name:")
cen = (f - 32) * 1.8;
far = (cen * 1.8) + 32;
print (cen, far);
</code></pre>
<p>Each line is of complexity O(1). Because its handling only one item.</p>
<p>4 * O(1) </p>
<p><strong>While finding the pattern we ignore the constant values.</strong> </p>
<p>So we remove 4 and the complexity is O(1)</p>
<h3 id="linear-complexity-on"><a class="header" href="#linear-complexity-on"><strong>Linear Complexity O(N)</strong></a></h3>
<p>In this case the time and size changes based on number of input values.</p>
<p>For example</p>
<pre><code>// Linear Complexity

for i = 1 to N
print (i)
</code></pre>
<p>if N = 10 it will be print faster, if N = 1Million the time taken will be linear.</p>
<p>These kinds of Linear changes is called  O(N)</p>
<h3 id="quadratic-complexity"><a class="header" href="#quadratic-complexity"><strong>Quadratic Complexity</strong></a></h3>
<pre><code>// Quadratic Complexity

for i = 1 to N
    for j = 1 to M
        print (i,j)   

</code></pre>
<p>For every i, there is another loop called j</p>
<p>N * N =  O(N Square)</p>
<p>If  N = 2 then the process will iterate  4 times. </p>
<h3 id="what-is-the-complexity-of-these-"><a class="header" href="#what-is-the-complexity-of-these-">What is the Complexity of these ?</a></h3>
<pre><code>//
for i = 1 to n
print (i)

for j = 1 to n
print (j)
</code></pre>
<pre><code>// 
for i = 1 to N
    for j = 1 to M
        for k = 1 to 1000
            print (i,j,k)
        
</code></pre>
<pre><code>// 
for (i = 0; i &lt; N; i++) {
    for (j = 0; j &lt; N; j++) {
        sequence of statements
    }
}
for (k = 0; k &lt; N; k++) {
    sequence of statements
}
</code></pre>
<h3 id="exponential-complexity"><a class="header" href="#exponential-complexity">Exponential Complexity</a></h3>
<p>O(2 power N)</p>
<p>With the increase in input there is an exponential growth in Time and Space.</p>
<p>Typical example : </p>
<pre><code>// Some code

function fibonacci(n){
    if n = 0 return 0
    if n = 1 return 1
    else
    return fibonacci(n - 2) + fibonacci(n - 1)
</code></pre>
<p>For example</p>
<p>For input = 3, number of iteration is 4   2 power n-1</p>
<p>For input = 4, number of iteration is 8 </p>
<pre><code>                                            Fibonacci(3)

                         Fibonacci(1)                            Fibonacci(2)

                                                    Fibonacci(0)         Fibonnaci(1)
</code></pre>
<h3 id="logarithmic-complexity--olog-n"><a class="header" href="#logarithmic-complexity--olog-n">Logarithmic Complexity  O(Log N)</a></h3>
<p>Increase in number of input is exponential but time and space growth is Linear.</p>
<pre><code>for (i= 1; i&lt; n; i = i **2)
    print(i)
</code></pre>
<p>or Binary Search</p>
<p>1  23  45  56  89  90  110  130</p>
<p>Pick mid point, search either left or right.</p>
<figure><img src="nice-to-know/../.gitbook/assets/big-o-complexity-chart.png" alt=""><figcaption><p>bigocheatsheet.com</p></figcaption></figure>
<p>Fore more visit</p>
<p>https://bigocheatsheet.com</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="important-concepts"><a class="header" href="#important-concepts">Important Concepts</a></h1>
<p>Date format</p>
<p><strong>Epoch Time:</strong> Unix Time is the number of seconds that have elapsed since Jan 1 1970 UTC.</p>
<p>https://www.epochconverter.com/</p>
<p>It uses 32 Bit Integer, so by Jan 19, Y2038 we will run out of storage and companies gradually upgrading it as they upgrade their systems.</p>
<p>Binary : 0 - 1</p>
<p>Octal : 0 - 7</p>
<p>Hex : 0 - 9, A - F</p>
<p>Base 10 a.k.a Decimal Numbers : 0 - 9</p>
<p>Base 36 : 0 - 9 + A - Z</p>
<p>Base 36 is the most compact case-insensitive alphanumeric numbering system.</p>
<p><strong>Popular Use Cases:</strong></p>
<ul>
<li>Base 36 is used for Dell Express Service Codes, website url shorteners and many other applications which have a need to minimize human error.</li>
<li>Reduce cloud storage cost.</li>
</ul>
<p>https://www.rapidtables.com/convert/number/base-converter.html</p>
<p><strong>Example:</strong> Processing 1 billion rows each hour for a day</p>
<p>Billion rows x 14 = 14 billion bytes = 14 GB x 24 hrs = 336 GB </p>
<p>Billion rows x 8 = 8 billion bytes = 8 GB x 24 hrs = 192 GB</p>
<p><strong>Base 64:</strong> </p>
<p>Base64 encoding schemes are commonly used when there is a need to encode binary data that needs be stored and transferred over media that are designed to deal with textual data. This is <strong>to ensure that the data remains intact without modification during transport</strong>.</p>
<p>Base64 is a way to encode binary data into an ASCII character set known to pretty much every computer system, in order <strong>to transmit the data without loss or modification of the contents itself</strong>.</p>
<p>2 power 6 = 64 </p>
<p>So Base64 Binary values are six bits not 8 bits.</p>
<figure><img src="nice-to-know/../.gitbook/assets/1_1pdlgVGk55PMx8wLQiQl_g.png" alt=""><figcaption><p><a href="https://medium.com/swlh/powering-the-internet-with-base64-d823ec5df747">https://medium.com/swlh/powering-the-internet-with-base64-d823ec5df747</a></p></figcaption></figure>
<p>Base64 encoding converts every three bytes of data (three bytes is 3*8=24 bits) into four base64 characters.</p>
<p>Example:</p>
<p>Convert Hi! to Base64</p>
<p>Character - Ascii - Binary</p>
<p>H= 72 = 01001000</p>
<p>i = 105 = 01101001</p>
<p>! = 33 = 00100001</p>
<p>Hi! = 01001000 01101001 00100001</p>
<p>Split into 4 parts<br />
<br />
<strong>010010  000110  100100  100001</strong></p>
<p><strong>S G k h</strong></p>
<p><a href="https://www.base64encode.org/">https://www.base64encode.org/</a></p>
<p>How about <strong>converting Hi to Base64</strong></p>
<p><strong>010010 000110 1001</strong></p>
<p>Add zeros in the end so its 6 characters long</p>
<p><strong>010010 000110 100100</strong></p>
<p>Base 64 is  SGk=</p>
<p>= is the padding character so the result is always multiple of 4.</p>
<p><strong>Another Example</strong></p>
<p>convert  f to Base64</p>
<p>102 = 01100110</p>
<p>011001 100000</p>
<p>Zg==</p>
<p>Think about sending Image (binary) as JSON, binary wont work. But sending as Base64 works the best.</p>
<p><a href="https://elmah.io/tools/base64-image-encoder/">https://elmah.io/tools/base64-image-encoder/</a></p>
<p>Demo  Img HTML</p>
<pre><code>// Convert to Base64

use base64::encode;
fn main() {
    let string = "Hello world!";
    let encoded = encode(string);
    println!("Base64: {}", encoded);
    
    let bin_string = b"Hello world!";
    let encoded1 = encode(bin_string);
    println!("Base64: {}", encoded1);
       
}
</code></pre>
<p><strong>Convert Base64 to String</strong></p>
<pre><code>// Convert to String

use base64::{encode,decode};
use std::str;

fn main() {
    let string = "Hello world!";
    let encoded = encode(string);
    println!("Base64: {}", encoded);
    
    let decoded = decode("SGVsbG8gd29ybGQh").unwrap();
    println!("{:?}",decoded);
    let converted_string = str::from_utf8(&amp;decoded).unwrap();
    println!("{:?}",converted_string);

}
</code></pre>
<p>Demonstrate what happens if unwrap is not used on decoded string.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-audit"><a class="header" href="#cargo-audit">Cargo Audit</a></h1>
<p>Goto command prompt or terminal and </p>
<pre><code>// How to install Cargo audit

cargo install cargo-audit
</code></pre>
<p>Go to the project you want to audit</p>
<pre><code>// Some code

cargo audit
</code></pre>
<p>Check the Vulnerable crates and fix as suggested.</p>
<p>Example:</p>
<p>Goto osinfo project</p>
<p>Change the dependency to  0.1.0</p>
<p>Run the cargo audit</p>
<p>Check the error messages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-profiles"><a class="header" href="#cargo-profiles">Cargo Profiles</a></h1>
<p>Profiles provide a way to alter the compiler settings, influencing things like optimizations and debugging symbols.</p>
<p>Cargo has 4 built-in profiles</p>
<ul>
<li>dev</li>
<li>release</li>
<li>test</li>
<li>bench</li>
</ul>
<p><a href="https://doc.rust-lang.org/cargo/reference/profiles.html">https://doc.rust-lang.org/cargo/reference/profiles.html</a>\</p>
<pre><code>[profile.dev]
opt-level = 0
debug = true
debug-assertions = true
overflow-checks = true
incremental = true


[profile.release]
opt-level = 3
debug = false
debug-assertions = false
overflow-checks = false
incremental = false
</code></pre>
<p><strong>Custom Profiles</strong></p>
<pre><code>// 

[profile.release-panic]
inherits = 'release'
panic = 'abort'
</code></pre>
<p>The specifications are selected based on the type of build.</p>
<pre><code>// dev profile is chosen
cargo build  

//release profile is chosen
cargo build --release

//Custom Profile
cargo build --profile release-panic
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>Official 'Stable' Rust Book</p>
<p>{% embed url="https://www.rust-lang.org/learn" %}</p>
<p>Official 'UnStable' Rust Book</p>
<p>{% embed url="https://doc.rust-lang.org/nightly/unstable-book/index.html" %}</p>
<p>{% embed url="https://www.udemy.com/course/rust-fundamentals/" %}</p>
<p>{% embed url="https://www.udemy.com/course/rust-programming-language-complete-tutorial/" %}</p>
<p>{% embed url="https://www.udemy.com/course/rust-lang/" %}</p>
<p>Stackoverflow Insights CSV</p>
<p>{% embed url="https://insights.stackoverflow.com/survey" %}</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
